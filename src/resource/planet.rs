use lazy_static::lazy_static;
use noise::{
    utils::{ColorGradient, ImageRenderer, NoiseMapBuilder, PlaneMapBuilder, SphereMapBuilder},
    *,
};

lazy_static! {
    /// Сид ключ для уникальной генерации планетарного ландшафта
    static ref CURRENT_SEED: u32 = 0;

    /// Частота континентов планеты. Более высокая частота производит
    /// более мелкие и многочисленные континенты.
    /// Значение измеряется в радианах.
    static ref CONTINENT_FREQUENCY: f64 = 1.0;

    /// Лакунарность континентов планеты. Изменение этого значения приводит к
    /// немного разные континенты. Для достижения наилучших результатов это значение должно
    /// быть случайным, но близким к 2.0.
    static ref CONTINENT_LACUNARITY: f64 = 2.208984375;

    /// Лакунарность гор планеты. Изменение значения производит
    /// немного другие горы. Для достижения наилучших результатов это значение должно
    /// быть случайным, но близким к 2.0.
    static ref MOUNTAIN_LACUNARITY: f64 = 2.142578125;

    /// Лакунарность холмов планеты. Изменение этого значения приводит к
    /// генерации других холмов. Для достижения наилучших результатов это значение должно быть
    /// случайно, но близко к 2.0.
    static ref HILLS_LACUNARITY: f64 = 2.162109375;

    /// Лакунарность равнин планеты. Изменение этого значения приводит к
    /// генерации других равнин. Для достижения наилучших результатов это значение должно быть
    /// случайно, но близко к 2.0.
    static ref PLAINS_LACUNARITY: f64 = 2.314453125;

    /// Лакунарность бесплодных земель планеты. Изменение этого значения приводит к
    /// генерации других бесплодных земль. Для достижения наилучших результатов это значение должно
    /// быть случайным, но близким к 2.0.
    static ref BADLANDS_LACUNARITY: f64 = 2.212890625;

    /// Определяет "извилистость" гор.
    static ref MOUNTAINS_TWIST: f64 = 1.0;

    /// Определяет «извилистость» холмов.
    static ref HILLS_TWIST: f64 = 1.0;

    /// Определяет «извилистость» бесплодных земель.
    static ref BADLANDS_TWIST: f64 = 1.0;

    /// Определяет уровень моря на планете. Это значение должно быть между -1,0
    /// (минимальная высота планеты) и +1.0 (максимальная высота планеты).
    static ref SEA_LEVEL: f64 = 0.0;

    /// Указывает уровень на планете, на котором появляются континентальные шельфы.
    /// Это значение должно быть между -1,0 (минимальная высота планеты) и +1,0
    /// (максимальная высота планеты) и должно быть меньше `SEA_LEVEL`.
    static ref SHELF_LEVEL: f64 = -0.375;

    /// Определяет количество гористой местности, которая появляется на
    /// планета. Значения варьируются от 0,0 (горы отсутствуют) до 1,0 (вся местность
    /// покрыто горами). Горный рельеф будет перекрывать холмистую местность.
    /// Поскольку местность бесплодных земель может перекрывать части горной местности
    /// местность, установка `MOUNTAINS_AMOUNT` на 1.0 может не полностью покрывать
    /// местность в горах.
    static ref MOUNTAINS_AMOUNT: f64 = 0.48;

    /// Определяет количество холмистой местности, которая появляется на планете.
    /// Значения варьируются от 0,0 (холмы отсутствуют) до 1,0 (вся местность покрыта
    /// холмы). Это значение должно быть меньше `MOUNTAINS_AMOUNT`. Поскольку
    /// горный рельеф будет перекрывать части холмистой местности, а
    /// ландшафт бесплодных земель может перекрывать части холмистой местности, устанавливая
    /// `HILLS_AMOUNT` на 1.0 может не полностью покрывать холмистую местность.
    static ref HILLS_AMOUNT: f64 = (1.0 + *MOUNTAINS_AMOUNT) / 2.0;

    /// Определяет количество бесплодных земель, покрывающих планету.
    /// Значения варьируются от 0,0 (без бесплодных земель) до 1,0 (вся местность покрыта
    /// бесплодные земли). Ландшафт бесплодных земель будет накладываться на любой другой тип ландшафта.
    static ref BADLANDS_AMOUNT: f64 = 0.3125;

    /// Смещение для применения к определению типа ландшафта. Низкие значения (< 1,0)
    /// заставляют шероховатые области появляться только на больших высотах. Высокие значения
    /// (> 2.0) заставляют шероховатые области появляться на любой высоте.
    /// процент грубых участков на планете не зависит от этого значения.
    static ref TERRAIN_OFFSET: f64 = 1.0;

    /// Определяет количество "оледенения" в горах. Это значение
    /// должен быть близок к 1,0 и больше 1,0.
    static ref MOUNTAIN_GLACIATION: f64 = 0.375;

    /// Масштабирование для применения к высотам базового континента в планетарных
    /// единицы высоты.
    static ref CONTINENT_HEIGHT_SCALE: f64 = (1.0 - *SEA_LEVEL) / 4.0;

    /// Максимальная глубина рек в планетарных единицах высоты.
    static ref RIVER_DEPTH: f64 = 0.0234375;
}

pub fn base_continent_def() -> utils::NoiseMap {
    /////////////////////////////////////////////////////////////////////////////
    // Группа функций: определение континента / continent_definition
    //////////////////////////////////////////////////// /////////////////////////

    /////////////////////////////////////////////////////////////////////////////
    // Подгруппа функций: определение базового континента / base_continent_definition
    // (7 функций шума)
    //
    // Эта подгруппа приблизительно определяет позиции и базовые отметки
    // континентов на планете.
    //
    // «Базовая отметка» — это отметка местности до того, как какая-либо местность
    // объекты (горы, холмы и т. д.) размещаются на этой местности.
    //
    // -1.0 представляет самую низкую высоту, а +1.0 представляет самую высокую
    // высоты.
    //

    // 1: [Модуль continent]: Модуль генерации континентов.
    // Функция шума имеет большое количество октав, поэтому детали видны на
    // высокие уровни масштабирования.
    let base_continent_def_fb0 = Fbm::new()
        .set_seed(*CURRENT_SEED)
        .set_frequency(*CONTINENT_FREQUENCY)
        .set_persistence(0.5)
        .set_lacunarity(*CONTINENT_LACUNARITY)
        .set_octaves(14);

    // 2: [Модуль сontinent_with_ranges] Определение положения горных хребтов.
    // Через функцию шума изменяет значения из модуля континентов, что позволяет отображать более
    // высокие значения ближе к уровню моря. Это определяет положение горных хребтов.
    let base_continent_def_cu: Curve<[f64; 3]> = Curve::new(&base_continent_def_fb0);
    let base_continent_def_cu: Curve<[f64; 3]> = base_continent_def_cu
        .add_control_point(-2.0000 + *SEA_LEVEL, -1.625 + *SEA_LEVEL)
        .add_control_point(-1.0000 + *SEA_LEVEL, -1.375 + *SEA_LEVEL)
        .add_control_point(0.0000 + *SEA_LEVEL, -0.375 + *SEA_LEVEL)
        .add_control_point(0.0625 + *SEA_LEVEL, 0.125 + *SEA_LEVEL)
        .add_control_point(0.1250 + *SEA_LEVEL, 0.250 + *SEA_LEVEL)
        .add_control_point(0.2500 + *SEA_LEVEL, 1.000 + *SEA_LEVEL)
        .add_control_point(0.5000 + *SEA_LEVEL, 0.250 + *SEA_LEVEL)
        .add_control_point(0.7500 + *SEA_LEVEL, 0.250 + *SEA_LEVEL)
        .add_control_point(1.0000 + *SEA_LEVEL, 0.500 + *SEA_LEVEL)
        .add_control_point(2.0000 + *SEA_LEVEL, 0.500 + *SEA_LEVEL);

    // 3: [модуль carver]: Высокочастотный модуль BasicMulti
    // Используется последующими шумовыми функциями для вырезания фрагментов из
    // горных хребтов в модуле "континент-с-хребтами", чтобы  горные хребты
    // не были полностью непроходимыми.
    let base_continent_def_fb1 = Fbm::new()
        .set_seed(*CURRENT_SEED + 1)
        .set_frequency(*CONTINENT_FREQUENCY * 4.34375)
        .set_persistence(0.5)
        .set_lacunarity(*CONTINENT_LACUNARITY)
        .set_octaves(11);

    // 4: [Модуль scaled_carver]: Модуль масштабирования/смещения.
    // Масштабирует выводимое значение из модуля carver обычно близкое к 1,0.
    // Это требуется для шага 5.
    let base_continent_def_sb: ScaleBias<[f64; 3]> = ScaleBias::new(&base_continent_def_fb1);
    let base_continent_def_sb: ScaleBias<[f64; 3]> =
        base_continent_def_sb.set_scale(0.375).set_bias(0.625);

    // 5: [Модуль carved_continent]: Этот модуль с минимальным значением вырезает
    // куски из модуля континентов с диапазонами. Он делает это, гарантируя
    // что только минимум выходных значений от масштабируемого модуля `сarver`
    // и модуль `сontinent_with_ranges` вносят свой вклад в вывод
    // значение этой подгруппы. В большинстве случаев модуль минимального значения будет
    // выбирать выходное значение из модуля `сontinent_with_ranges`, так как
    // выходное значение масштабируемого резчика обычно близко к 1,0. Время от времени,
    // вывод модуля `scaled_carver` будет меньше, чем вывод значение из модуля `сontinent_with_ranges`.
    let base_continent_def_mi: Min<[f64; 3]> =
        Min::new(&base_continent_def_sb, &base_continent_def_cu);

    // 6: [Модуль clamped_continent]
    // Изменяю вырезаемое модулем `continent`, чтобы гарантировать, что выходное значение
    //  этой подгруппы между -1,0 и 1,0.
    let base_continent_def_cl: Clamp<[f64; 3]> =
        Clamp::new(&base_continent_def_mi).set_bounds(-1.0, 1.0);

    // 7: [Подгруппа base_continent_definition]: Кеширую выходное значение из
    // модуля `clamped_continent`.
    let base_continent_def = Cache::new(base_continent_def_cl);

    // ////////////////////////////////////////////////////////////////////////
    // Подгруппа функций: определение континента / continent_definition (5 функций шума)
    //
    // Эта подгруппа искажает выходное значение из определения базового континента
    // подгруппа, создающая более реалистичный ландшафт.
    //
    // Деформация определения базового континента создает более бугристую местность с
    // скалами и трещинами
    //
    // -1.0 представляет самую низкую высоту, а +1.0 представляет самую высокую
    // высоты.
    //

    // 1: [Модуль coarse_turbulence]: Модуль турбулентности искажает вывод
    // значение из подгруппы base_continent_definition, добавляя некоторые грубые
    // деталь к нему.
    let continent_def_tu0 = Turbulence::<_>::new(&base_continent_def)
        .set_seed(*CURRENT_SEED + 10)
        .set_frequency(*CONTINENT_FREQUENCY * 15.25)
        .set_power(*CONTINENT_FREQUENCY / 113.75)
        .set_roughness(13);

    // 2: [Модуль intermediate_turbulence]: Этот модуль турбулентности искажает
    // выходное значение из модуля `coarse_turbulence`. Эта турбулентность имеет
    // более высокие частоты, но меньшую мощность, чем у модуля `coarse_turbulence`,
    // что добавляем какую-то промежуточную деталь.
    let continent_def_tu1 = Turbulence::<_>::new(continent_def_tu0)
        .set_seed(*CURRENT_SEED + 11)
        .set_frequency(*CONTINENT_FREQUENCY * 47.25)
        .set_power(*CONTINENT_FREQUENCY / 433.75)
        .set_roughness(12);

    // 3: [Модуль warped_base_continent_definition]: Этот модуль турбулентности
    // искажает выходное значение модуля `intermediate_turbulence`.
    // Турбулентность имеет более высокую частоту, но меньшую мощность, чем
    // модуль `intermediate_turbulence`, добавляя к нему мелкие детали.
    let continent_def_tu2 = Turbulence::<_>::new(continent_def_tu1)
        .set_seed(*CURRENT_SEED + 12)
        .set_frequency(*CONTINENT_FREQUENCY * 95.25)
        .set_power(*CONTINENT_FREQUENCY / 1019.75)
        .set_roughness(11);

    // 4: [Модуль select_turbulence]: На этом этапе применяется турбулентность
    // ко всей подгруппе определения базового континента, производя очень
    // бурные, нереальные береговые линии. Этот селекторный модуль выбирает
    // выходные значения из (недеформированной) подгруппы base_continent_definition
    // и модуля warped_base_continent_definition на их основе выводя
    // значение из (недеформированной) подгруппы определения базового континента.
    // Граница выделения находится вблизи уровня моря и имеет относительно гладкую
    // переход. Фактически, только более высокие области базового континента
    // искажается; подводные и прибрежные зоны остаются незатронутыми.
    let continent_def_se =
        Select::new(&base_continent_def, &continent_def_tu2, &base_continent_def)
            .set_bounds(*SEA_LEVEL - 0.0375, *SEA_LEVEL + 1000.0375)
            .set_falloff(0.0625);

    // 5: [Группа continent_definition]: Кэширует выходное значение из
    // модуля continent_definition. Это выходное значение для всей группы
    // функций определения континента.
    let continent_def = Cache::new(&continent_def_se);

    //////////////////////////////////////////////////// /////////////////////////
    // Группа функций: определение типа местности / terrain_type_definition
    //////////////////////////////////////////////////// /////////////////////////

    //////////////////////////////////////////////////// /////////////////////////
    // Подгруппа функций: определение типа местности (3 функции шума)
    //
    // Эта подгруппа определяет положение типов местности на планете.
    //
    // Типы местности включают, в порядке возрастания шероховатости, равнины, холмы,
    // и горы.
    //
    // Выходное значение этой подгруппы основано на выходном значении из
    // группы `continent_definition`.
    // Более пересеченная местность в основном появляется на более высоких участках
    //
    // -1.0 представляет самые гладкие типы местности (равнины и под водой) и
    // +1.0 представляет самые пересеченные типы местности (горы).
    //

    // 1: [Модуль warped_continent]: Этот модуль турбулентности немного искажает
    // выходное значение из группы `continent_definition`. Это предотвращает появление
    // грубой местность исключительно на возвышенностях. Грубе области ландшафта теперь
    // могут появляться в океане, создавая скалистые острова и фьорды.
    let terrain_type_def_tu = Turbulence::<_>::new(&continent_def)
        .set_seed(*CURRENT_SEED + 20)
        .set_frequency(*CONTINENT_FREQUENCY * 18.125)
        .set_power(*CONTINENT_FREQUENCY / 20.59375 * *TERRAIN_OFFSET)
        .set_roughness(3);

    // 2: [Модуль roughness_probability_shift]: Этот модуль террасирования заостряет
    // края модуля `warped_continent` у уровня моря и опускает уклон в сторону
    // возвышенностей, что позволяет сузить области в которых появляется
    // пересеченная местность, повышая "редкость" пересеченной местности
    // местность.
    let terrain_type_def_te = Terrace::new(&terrain_type_def_tu)
        .add_control_point(-1.00)
        .add_control_point(*SHELF_LEVEL + *SEA_LEVEL / 2.0)
        .add_control_point(1.00);

    // 3: [Группа terrain_type_definition]: Кэширую выходное значение из
    // модуля `roughness_probability_shift`. Это выходное значение для
    // вся группы `terrain-type-definition`.
    let terrain_type_def = Cache::new(terrain_type_def_te);

    //////////////////////////////////////////////////// //////////////////////////
    // Группа функций: Гористая местность / mountainous_terrain
    //////////////////////////////////////////////////// //////////////////////////

    //////////////////////////////////////////////////// //////////////////////////
    // Подгруппа функций: определение основания горы (9 функций шума)
    //
    // Эта подгруппа генерирует высоты подножия горы. Другие подгруппы
    // добавят хребты и понижения к базовым отметкам.
    //
    // -1.0 представляет низкую гористую местность и +1.0 представляет высокую
    // гористая местность.
    //

    // 1: [Функция mountain_ridge]: Функция ребристого мультифрактального шума
    // генерирует горные хребты.
    let mountain_base_def_rm0 = RidgedMulti::new()
        .set_seed(*CURRENT_SEED + 30)
        .set_frequency(1723.0)
        .set_lacunarity(*MOUNTAIN_LACUNARITY)
        .set_octaves(4);

    // 2: [Функция scaled_mountain_ridge]: Функция масштаба/смещения масштабирует
    // выводимое значение из функции `mountain_ridge` так, чтобы его хребты не были
    // слишком высоко. Делаю это, чтобы позже в другой подгруппе добавить фактическую
    // гористую местность к этим хребтам.
    let mountain_base_def_sb0: ScaleBias<[f64; 3]> = ScaleBias::new(&mountain_base_def_rm0);
    let mountain_base_def_sb0 = mountain_base_def_sb0.set_scale(0.5).set_bias(0.375);

    // 3: [Функция river_valley]: Функция ребристого мультифрактального шума
    // генерирует речные долины. Она имеет гораздо более низкую частоту, чем
    // модуль горных хребтов, чтобы снаружи появилось больше горных хребтов
    // долин. Важно отместить, что эта шумовая функция генерирует
    // ребристо-мультифрактальные шум, использующий только одну октаву
    let mountain_base_def_rm1 = RidgedMulti::new().set_seed(*CURRENT_SEED + 31);
    let mountain_base_def_rm1 = mountain_base_def_rm1
        .set_frequency(367.0)
        .set_lacunarity(*MOUNTAIN_LACUNARITY)
        .set_octaves(1);

    // 4: [Функция scaled_river_valley]: Функция масштаба/смещения применяет
    // коэффициент масштабирования -2.0 для выходного значения функции `river_valley`.
    // Это растягивает возможные значения высоты, потому что ребро на одну октаву
    // мультифрактального шума имеет меньший диапазон выходных значений, чем
    // ребристо-мультифрактальный шум. Отрицательный коэффициент масштабирования инвертирует
    // диапазон выходного значения, поворачивая хребты от выходного значения `river_valley`.
    let mountain_base_def_sb1: ScaleBias<[f64; 3]> = ScaleBias::new(&mountain_base_def_rm1);
    let mountain_base_def_sb1 = mountain_base_def_sb1.set_scale(-2.0).set_bias(-0.5);

    // 5: [low_flat]: это низкое постоянное значение используется на шаге 6.
    let mountain_base_def_co = Constant::new(-1.0);

    // 6: [mountains_and_valleys]: Этот модуль блендера объединяет
    // модуль `scaled_mountain_ridge` и модуль `scaled_river_valley` вместе. Это
    // заставляет низменные участки местности становиться гладкими и вызывает
    // возвышенные участки местности для гребней. Для этого он
    // использует модуль `scaled_river_valley` в качестве модуля управления, вызывая
    // появления результатов `low-flat` в нижних областях и вызывает масштабирование
    // горного хребта в более высоких областях.
    let mountain_base_def_bl: Blend<[f64; 3]> = Blend::new(
        &mountain_base_def_co,
        &mountain_base_def_sb0,
        &mountain_base_def_sb1,
    );

    // 7: [Модуль грубой турбулентности]: этот модуль турбулентности искажает вывод
    // значение из модуля Mountain-and-Valleys, добавляющее некоторые грубые детали к
    // Это.
    let mountain_base_def_tu0 = Turbulence::<_>::new(&mountain_base_def_bl)
        .set_seed(*CURRENT_SEED + 32)
        .set_frequency(1337.0)
        .set_power(1.0 / 6730.0 * *MOUNTAINS_TWIST)
        .set_roughness(4);

    // 8: [Модуль искривленных гор и долин]: Этот модуль турбулентности искривляет
    // выходное значение модуля грубой турбулентности. Эта турбулентность имеет
    // более высокая частота, но меньшая мощность, чем у модуля грубой турбулентности,
    // добавляем к нему мелкие детали.
    let mountain_base_def_tu1: Turbulence<&Turbulence<&Blend<[f64; 3]>>> =
        Turbulence::<_>::new(&mountain_base_def_tu0)
            .set_seed(*CURRENT_SEED + 33)
            .set_frequency(21221.0)
            .set_power(1.0 / 120157.0 * *MOUNTAINS_TWIST)
            .set_roughness(6);

    // 9: [Подгруппа определения горной базы]: кэширует выходное значение из
    // модуль искривленных гор и долин.
    let mountain_base_def = Cache::new(&mountain_base_def_tu1);

    //////////////////////////////////////////////////// //////////////////////////
    // Подгруппа функций: высокогорная местность (5 функций шума)
    //
    // Эта подгруппа генерирует гористую местность, которая появляется на высоте
    // возвышенности в пределах горных хребтов.
    //
    // -1.0 представляет самую низкую высоту, а +1.0 представляет самую высокую
    // высоты.
    //

    // 1: [Mountain-basis-0 module]: эта функция ребристого мультифрактального шума,
    // вместе с модулем Mountain-Basis-1 генерирует индивидуальный
    // горы.
    let mountainous_high_rm0 = RidgedMulti::new().set_seed(*CURRENT_SEED + 40);
    let mountainous_high_rm0 = mountainous_high_rm0
        .set_frequency(2371.0)
        .set_lacunarity(*MOUNTAIN_LACUNARITY)
        .set_octaves(3);

    // 2: [Mountain-basis-1 module]: эта функция ребристого мультифрактального шума,
    // вместе с модулем Mountain-Basis-0 генерирует индивидуальный
    // горы.
    let mountainous_high_rm1 = RidgedMulti::new().set_seed(*CURRENT_SEED + 41);
    let mountainous_high_rm1 = mountainous_high_rm1
        .set_frequency(2341.0)
        .set_lacunarity(*MOUNTAIN_LACUNARITY)
        .set_octaves(3);

    // 3: [Модуль высокогорья]: затем модуль максимального значения вызывает больше
    // горы появятся за счет долин. Это достигается за счет обеспечения
    // что только максимум выходных значений из двух ребристых
    // функции мультифрактального шума вносят свой вклад в выходное значение этого
    // подгруппа.
    let mountainous_high_ma: Max<[f64; 3]> = Max::new(&mountainous_high_rm0, &mountainous_high_rm1);

    // 4: [Модуль искажения высокогорья]: Этот модуль турбулентности искажает
    // выводим значение из модуля высокогорья, добавляя к нему детали.
    let mountainous_high_tu = Turbulence::<_>::new(&mountainous_high_ma)
        .set_seed(*CURRENT_SEED + 42)
        .set_frequency(31511.0)
        .set_power(1.0 / 180371.0 * *MOUNTAINS_TWIST)
        .set_roughness(4);

    // 5: [Подгруппа высокогорной местности]: Кэширует выходное значение из
    // модуль warped-high-mountains.
    let mountainous_high = Cache::new(mountainous_high_tu);

    //////////////////////////////////////////////////// //////////////////////////
    // Подгруппа функций: низкогорная местность (4 шумовые функции)
    //
    // Эта подгруппа генерирует гористую местность, которая появляется при низких
    // возвышенности в долинах рек.
    //
    // -1.0 представляет самую низкую высоту, а +1.0 представляет самую высокую
    // высоты.
    //

    // 1: [модуль Lowland-basis-0]: эта функция ребристого мультифрактального шума,
    // вместе с модулем lowland-basis-1 выдает низкий горный
    // местность.
    let mountainous_low_rm0 = RidgedMulti::new()
        .set_seed(*CURRENT_SEED + 50)
        .set_frequency(1381.0)
        .set_lacunarity(*MOUNTAIN_LACUNARITY)
        .set_octaves(8);

    // 1: [модуль Lowland-basis-1]: эта функция ребристого мультифрактального шума,
    // вместе с модулем lowland-basis-0 выдает низкий горный
    // местность.
    let mountainous_low_rm1 = RidgedMulti::new()
        .set_seed(*CURRENT_SEED + 51)
        .set_frequency(1427.0)
        .set_lacunarity(*MOUNTAIN_LACUNARITY)
        .set_octaves(8);

    // 3: [Модуль низкогорья]: Этот модуль умножения объединяет
    // выходные значения двух функций гребенчатого мультифрактального шума. Этот
    // вызывает появление следующего в результирующем ландшафте:
    // - Трещины появляются при перемножении двух отрицательных выходных значений.
    // - Плоские области появляются, когда положительное и отрицательное выходное значение
    // перемножаются.
    // - Ребра появляются при перемножении двух положительных выходных значений.
    let mountainous_low_mu: Multiply<[f64; 3]> =
        Multiply::new(&mountainous_low_rm0, &mountainous_low_rm1);

    // 4: [Подгруппа низкогорья]: Кэширует выходное значение из
    // модуль низкогорья.
    let mountainous_low = Cache::new(&mountainous_low_mu);

    //////////////////////////////////////////////////// //////////////////////////
    // Подгруппа функций: горная местность (7 функций шума)
    //
    // Эта подгруппа генерирует окончательный горный ландшафт, комбинируя
    // высокогорная подгруппа с низкогорной
    // подгруппа.
    //
    // -1.0 представляет самую низкую высоту, а +1.0 представляет самую высокую
    // высоты.
    //
    // 1: [Модуль масштабирования-низкогорной местности]: во-первых, этот модуль масштаба/смещения
    // масштабирует выходное значение из подгруппы низкогорной местности до очень
    // низкое значение и смещает его в сторону -1.0. Это приводит к низкому горному
    // области становятся более или менее плоскими с небольшими изменениями. Это также
    // в результате низкие горные районы появляются на самых низких высотах в
    // эта подгруппа.
    let mountainous_terrain_sb0 = ScaleBias::new(&mountainous_low)
        .set_scale(0.03125)
        .set_bias(-0.96875);

    // 2: [Модуль масштабирования высокогорной местности]: Далее этот модуль масштабирования/смещения
    // масштабирует выходное значение из подгруппы высокогорной местности до 1/4
    // своего начального значения и смещает его так, чтобы его выходное значение обычно
    // положительный.
    let mountainous_terrain_sb1 = ScaleBias::new(&mountainous_high)
        .set_scale(0.25)
        .set_bias(0.25);

    // 3: [Добавлен модуль высокогорной местности]: этот дополнительный модуль добавляет
    // выводим значение из модуля scaled-high-mountainous-terrain в
    // выходное значение из подгруппы определения горы. Горы сейчас
    // появляются по всей местности.
    let mountainous_terrain_ad: Add<[f64; 3]> =
        Add::new(&mountainous_terrain_sb1, &mountain_base_def);

    // 4: [Комбинированный модуль горной местности]: Обратите внимание, что в этот момент
    // вся местность покрыта высокогорной местностью, даже на низких
    // высоты. Чтобы горы появлялись только наверху
    // возвышения, этот модуль селектора вызывает отображение низкой гористой местности
    // в низкогорьях (в долинах) и высокогорных
    // местность появится на возвышенностях (внутри хребтов). Сделать это,
    // эта шумовая функция выбирает выходное значение из добавленного высокого
    // модуль горной местности, если выходное значение из горной базы
    // подгруппа определения выше установленной суммы. Иначе этот шум
    // модуль выбирает выходное значение из масштабированного низкогорного ландшафта
    // модуль.
    let mountainous_terrain_se = Select::new(
        &mountainous_terrain_sb0,
        &mountainous_terrain_ad,
        &mountain_base_def,
    )
    .set_bounds(-0.5, 999.5)
    .set_falloff(0.5);

    // 5: [Scaled-mountainous-terrain-module]: Этот модуль масштаба/смещения немного
    // уменьшает диапазон выходного значения от комбинированного горно-
    // модуль ландшафта, уменьшающий высоту горных вершин.
    let mountainous_terrain_sb2 = ScaleBias::new(&mountainous_terrain_se)
        .set_scale(0.8)
        .set_bias(0.0);

    // 6: [Модуль покрытой льдом горной местности]: этот модуль экспоненциальной кривой
    // применяет экспоненциальную кривую к выходному значению масштабированного
    // горно-ландшафтный модуль. Это приводит к тому, что склоны гор
    // плавно увеличиваемся к более высоким отметкам, как если бы ледник стачивался
    // эти горы. Этот модуль экспоненциальной кривой ожидает выходное значение
    // в диапазоне от -1,0 до +1,0.
    let mountainous_terrain_ex =
        Exponent::new(&mountainous_terrain_sb2).set_exponent(*MOUNTAIN_GLACIATION);

    let mountainous_terrain = Cache::new(&mountainous_terrain_ex);

    //////////////////////////////////////////////////// /////////////////////////
    // Группа функций: холмистая местность
    //////////////////////////////////////////////////// /////////////////////////

    //////////////////////////////////////////////////// /////////////////////////
    // Подгруппа функций: холмистая местность (11 функций шума)
    //
    // Эта подгруппа генерирует холмистую местность.
    //
    // -1.0 представляет самую низкую высоту, а +1.0 представляет самую высокую
    // высоты.
    //

    // 1: [Модуль холмов]: эта функция волнового шума генерирует холмы.
    let hilly_terrain_bi = Billow::new()
        .set_seed(*CURRENT_SEED + 60)
        .set_frequency(1663.0)
        .set_persistence(0.5)
        .set_lacunarity(*HILLS_LACUNARITY)
        .set_octaves(6);

    // 2: [Модуль Scaled-hills]: затем модуль масштабирования/смещения масштабирует вывод
    // значение из модуля hills, чтобы его вершины не были слишком высокими.
    // причина этого в том, что эти холмы со временем добавляются к реке
    // долины (см. ниже).
    let hilly_terrain_sb0: ScaleBias<[f64; 3]> = ScaleBias::new(&hilly_terrain_bi);
    let hilly_terrain_sb0 = hilly_terrain_sb0.set_scale(0.5).set_bias(0.5);

    // 3: [Модуль речной долины]: эта функция ребристого мультифрактального шума генерирует
    // речные долины. Он имеет гораздо более низкую частоту, поэтому будет больше холмов.
    // появляются между долинами. Обратите внимание, что эта шумовая функция генерирует
    // ребристо-мультифрактальный шум, использующий только одну октаву; эта информация будет
    // важно на следующем шаге.
    let hilly_terrain_rm = RidgedMulti::new()
        .set_seed(*CURRENT_SEED + 61)
        .set_frequency(367.5)
        .set_lacunarity(*HILLS_LACUNARITY)
        .set_octaves(1);

    // 4: [Модуль Scaled-river-valley]: затем модуль масштаба/смещения применяет
    // Коэффициент масштабирования -2.0 для выходного значения модуля речной долины.
    // Это растягивает возможные значения высоты, потому что ребро на одну октаву
    // мультифрактальный шум имеет меньший диапазон выходных значений, чем мультифрактальный шум.
    // октавный ребристо-мультифрактальный шум. Отрицательный коэффициент масштабирования инвертирует
    // диапазон выходного значения, поворачивая хребты от реки-долины
    // модуль в долины.
    let hilly_terrain_sb1: ScaleBias<[f64; 3]> = ScaleBias::new(&hilly_terrain_rm);
    let hilly_terrain_sb1 = hilly_terrain_sb1.set_scale(-2.0).set_bias(-1.0);

    // 5: [Низкий плоский модуль]: это низкое постоянное значение используется на шаге 6.
    let hilly_terrain_co = Constant::new(-1.0);

    // 6: [Модуль гор и долин]: Этот модуль блендера объединяет
    // модуль холмов и модуль Scaled-River-Valley вместе. Это вызывает
    // низменные участки местности становятся гладкими, что приводит к
    // лежащие участки местности, содержащие холмы. Для этого он использует использует
    // модуль Scaled-Hills в качестве модуля управления, в результате чего модуль Low Flat
    // появляются в нижних областях и заставляют модуль Scaled-River-Valley
    // появляются в более высоких областях.
    let hilly_terrain_bl: Blend<[f64; 3]> =
        Blend::new(&hilly_terrain_co, &hilly_terrain_sb1, &hilly_terrain_sb0);

    // 7: [Модуль масштаба холмов и долин]: этот модуль масштаба/смещения немного
    // уменьшает диапазон выходного значения от холмов и долин
    // модуль, уменьшающий высоты вершин холмов.
    let hilly_terrain_sb2: ScaleBias<[f64; 3]> = ScaleBias::new(&hilly_terrain_bl)
        .set_scale(0.75)
        .set_bias(-0.25);

    // 8: [Модуль увеличенного склона холмистой местности]: увеличить уклон холма
    // на больших высотах этот модуль экспоненциальной кривой применяет
    // экспоненциальная кривая к выходному значению в масштабе холмов и долин
    // модуль. Этот модуль экспоненциальной кривой ожидает, что входное значение будет находиться в диапазоне
    // от -1,0 до 1,0.
    let hilly_terrain_ex = Exponent::new(&hilly_terrain_sb2).set_exponent(1.375);

    // 9: [Модуль грубой турбулентности]: этот модуль турбулентности искажает вывод
    // значение из модуля увеличенного наклона холмистой местности, добавляя немного
    // грубая детализация.
    let hilly_terrain_tu0: Turbulence<&Exponent<[f64; 3]>> = Turbulence::new(&hilly_terrain_ex)
        .set_seed(*CURRENT_SEED + 62)
        .set_frequency(1531.0)
        .set_power(1.0 / 16921.0 * *HILLS_TWIST)
        .set_roughness(4);

    // 10: [Модуль искривленной холмистой местности]: Этот модуль турбулентности искажает
    // выходное значение из модуля грубой турбулентности. Эта турбулентность имеет
    // более высокая частота, но меньшая мощность, чем у модуля грубой турбулентности,
    // добавляем к нему мелкие детали.
    let hilly_terrain_tu1 = Turbulence::<_>::new(&hilly_terrain_tu0)
        .set_seed(*CURRENT_SEED + 63)
        .set_frequency(21617.0)
        .set_power(1.0 / 117529.0 * *HILLS_TWIST)
        .set_roughness(6);

    // 11: [Группа холмистой местности]: Кэширует выходное значение из деформированной холмистой местности.
    // модуль местности. Это выходное значение для всей холмистой местности.
    // группа.
    let hilly_terrain = Cache::new(hilly_terrain_tu1);

    //////////////////////////////////////////////////// /////////////////////////
    // Группа функций: равнинная местность
    //////////////////////////////////////////////////// /////////////////////////

    //////////////////////////////////////////////////// /////////////////////////
    // Подгруппа функций: равнинная местность (7 функций шума)
    //
    // Эта подгруппа генерирует равнинный ландшафт.
    //
    // Поскольку эта подгруппа в конечном итоге будет значительно сплющена,
    // типы и комбинации шумовых функций, которые генерируют равнины, не
    // действительно так важно; им нужно только «выглядеть» интересно.
    //
    // -1.0 представляет самую низкую высоту, а +1.0 представляет самую высокую
    // высоты.
    //

    // 1: [Модуль Plains-basis-0]: Эта функция шумоподавления вместе с
    // модуль plains-basis-1, создает равнины.
    let plains_terrain_bi0 = Billow::new()
        .set_seed(*CURRENT_SEED + 70)
        .set_frequency(1097.5)
        .set_persistence(0.5)
        .set_lacunarity(*PLAINS_LACUNARITY)
        .set_octaves(8);

    // 2: [модуль Positive-plains-basis-0]: этот модуль масштаба/смещения делает
    // выходное значение из модуля plains-basis-0 положительное, так как этот вывод
    // значение будет умножено вместе с положительной базой равнин-1
    // модуль.
    let plains_terrain_sb0: ScaleBias<[f64; 3]> = ScaleBias::new(&plains_terrain_bi0);
    let plains_terrain_sb0 = plains_terrain_sb0.set_scale(0.5).set_bias(0.5);

    // 3: [Модуль Plains-basis-1]: Эта функция шумоподавления вместе с
    // модуль plains-basis-2, создает равнины.
    let plains_terrain_bi1 = Billow::new()
        .set_seed(*CURRENT_SEED + 71)
        .set_frequency(1097.5)
        .set_persistence(0.5)
        .set_lacunarity(*PLAINS_LACUNARITY)
        .set_octaves(8);

    // 4: [модуль Positive-plains-basis-1]: этот модуль масштаба/смещения делает
    // выходное значение из модуля plains-basis-1 положительное, так как этот вывод
    // значение будет умножено на положительный базис равнины-0
    // модуль.
    let plains_terrain_sb1: ScaleBias<[f64; 3]> = ScaleBias::new(&plains_terrain_bi1);
    let plains_terrain_sb1 = plains_terrain_sb1.set_scale(0.5).set_bias(0.5);

    // 5: [Комбинированный базовый модуль]: Этот модуль умножения объединяет
    // два базовых модуля равнин вместе.
    let plains_terrain_mu: Multiply<[f64; 3]> =
        Multiply::new(&plains_terrain_sb0, &plains_terrain_sb1);

    // 6: [модуль Rescaled-plains-basis]: этот модуль масштабирования/смещения отображает вывод
    // значение в диапазоне от 0,0 до 1,0 обратно к значению в диапазоне от
    // от -1,0 до +1,0.
    let plains_terrain_sb2: ScaleBias<[f64; 3]> = ScaleBias::new(&plains_terrain_mu)
        .set_scale(2.0)
        .set_bias(-1.0);

    // 7: [Группа Plains-terrain]: Кэширует выходное значение из перемасштабированного
    // базовый модуль равнин. Это выходное значение для всей равнины.
    // группа местности.
    let plains_terrain: Cache<ScaleBias<[f64; 3]>> = Cache::new(plains_terrain_sb2);

    //////////////////////////////////////////////////// /////////////////////////
    // Группа функций: ландшафт бесплодных земель
    //////////////////////////////////////////////////// /////////////////////////

    //////////////////////////////////////////////////// /////////////////////////
    // Подгруппа функций: песок бесплодных земель (6 функций шума)
    //
    // Эта подгруппа генерирует песчаный ландшафт для бесплодных земель.
    //
    // -1.0 представляет самую низкую высоту, а +1.0 представляет самую высокую
    // высоты.
    //

    // 1: [Модуль песчаных дюн]: эта функция ребристого мультифрактального шума генерирует
    // песчаные дюны. Этот ребристо-мультифрактальный шум генерируется с помощью одного
    // октава, что делает дюны очень гладкими.
    let badlands_sand_rm = RidgedMulti::new()
        .set_seed(*CURRENT_SEED + 80)
        .set_frequency(6163.5)
        .set_lacunarity(*BADLANDS_LACUNARITY)
        .set_octaves(1);

    // 2: [Модуль чешуйчатых песчаных дюн]: этот модуль масштаба/смещения уменьшает дюну
    // высота на небольшую величину. Это необходимо для того, чтобы в последующем
    // шумовые функции в этой подгруппе могут добавить некоторые детали дюнам.
    let badlands_sand_sb0: ScaleBias<[f64; 3]> = ScaleBias::new(&badlands_sand_rm);
    let badlands_sand_sb0 = badlands_sand_sb0.set_scale(0.875).set_bias(0.0);

    // 3: [Модуль деталей дюны]: Эта шумовая функция использует полигоны Вороного для
    // генерируем детали для добавления к дюнам. Включив дистанцию
    // алгоритм, генерируются небольшие полигональные ямы; края ям
    // присоединяются к краям близлежащих ям.
    let badlands_sand_wo = Worley::new()
        .set_seed(*CURRENT_SEED + 81)
        .set_frequency(16183.25);

    // 4: [Scaled-dune-detail module]: Этот модуль масштабирования/смещения уменьшает дюну
    // детали на большое количество. Это необходимо для того, чтобы в последующем
    // шумовые функции в этой подгруппе могут добавить эту деталь к песчаным дюнам
    // модуль.
    let badlands_sand_sb1: ScaleBias<[f64; 3]> = ScaleBias::new(&badlands_sand_wo);
    let badlands_sand_sb1 = badlands_sand_sb1.set_scale(0.25).set_bias(0.25);

    // 5: [Модуль «Дюны с деталями»]: Этот дополнительный модуль сочетает в себе
    // модуль песчаных дюн с модулем Scaled-Dune-Detail.
    let badlands_sand_ad = Add::new(&badlands_sand_sb0, &badlands_sand_sb1);

    // 6: [Подгруппа Badlands-sand]: кэширует выходное значение из дюн-с-
    // детальный модуль.
    let badlands_sand: Cache<&Add<[f64; 3]>> = Cache::new(&badlands_sand_ad);

    //////////////////////////////////////////////////// /////////////////////////
    // Подгруппа функций: скалы бесплодных земель (7 функций шума)
    //
    // Эта подгруппа генерирует скалы для бесплодных земель.
    //
    // -1.0 представляет самую низкую высоту, а +1.0 представляет самую высокую
    // высоты.
    //

    // 1: [модуль Cliff-basis]: эта функция шума Перлина генерирует некоторое когерентное
    // шум, который будет использоваться для создания обрывов.
    let badlands_cliffs_fb = Fbm::new()
        .set_seed(*CURRENT_SEED + 90)
        .set_frequency(*CONTINENT_FREQUENCY * 839.0)
        .set_persistence(0.5)
        .set_lacunarity(*BADLANDS_LACUNARITY)
        .set_octaves(6);

    // 2: [Модуль формирования обрыва]: затем этот модуль кривой применяет кривую к
    // выходное значение из модуля обрыва. Эта кривая изначально
    // очень пологая, но затем ее наклон резко возрастает. На самом высоком
    // высоты кривая снова становится очень плоской. Это производит
    // стереотипные пустынные скалы в стиле Юты.
    let badlands_cliffs_cu: Curve<[f64; 3]> = Curve::new(&badlands_cliffs_fb);
    let badlands_cliffs_cu = badlands_cliffs_cu
        .add_control_point(-2.000, -2.000)
        .add_control_point(-1.000, -1.000)
        .add_control_point(-0.000, -0.750)
        .add_control_point(0.500, -0.250)
        .add_control_point(0.625, 0.875)
        .add_control_point(0.750, 1.000)
        .add_control_point(2.000, 1.250);

    // 3: [Модуль зажатых скал]: Этот модуль зажима делает вершины
    // обрывы очень плоские, зажимая выходное значение от формирования обрыва
    // модуль.
    let badlands_cliffs_cl = Clamp::new(&badlands_cliffs_cu).set_bounds(-999.125, 0.875);

    // 4: [Модуль террасных скал]: Далее этот модуль террас применяет некоторые
    // террасы к модулю зажатых скал в нижних отметках перед
    // резкий переход обрыва.
    let badlands_cliffs_te: Terrace<[f64; 3]> = Terrace::new(&badlands_cliffs_cl)
        .add_control_point(-1.000)
        .add_control_point(-0.875)
        .add_control_point(-0.750)
        .add_control_point(-0.500)
        .add_control_point(0.000)
        .add_control_point(1.000);

    // 5: [Модуль грубой турбулентности]: этот модуль турбулентности искажает вывод
    // значение из модуля Terrad-Cliffs, добавляя к нему некоторые грубые детали.
    let badlands_cliffs_tu0: Turbulence<&Terrace<[f64; 3]>> = Turbulence::new(&badlands_cliffs_te)
        .set_seed(*CURRENT_SEED + 91)
        .set_frequency(16111.0)
        .set_power(1.0 / 141539.0 * *BADLANDS_TWIST)
        .set_roughness(3);

    // 6: [Модуль искривленных скал]: Этот модуль турбулентности искажает выходное значение
    // из модуля грубой турбулентности. Эта турбулентность имеет более высокую
    // частота, но меньшая мощность, чем у модуля грубой турбулентности, добавление
    // некоторые мелкие детали.
    let badlands_cliffs_tu1: Turbulence<&Turbulence<&Terrace<[f64; 3]>>> =
        Turbulence::new(&badlands_cliffs_tu0)
            .set_seed(*CURRENT_SEED + 92)
            .set_frequency(36107.0)
            .set_power(1.0 / 211543.0 * *BADLANDS_TWIST)
            .set_roughness(3);

    // 7: [Подгруппа Badlands-cliffs]: Кэширует выходное значение из деформированного
    // модуль скал.
    let badlands_cliffs = Cache::new(&badlands_cliffs_tu1);

    //////////////////////////////////////////////////// /////////////////////////
    // Подгруппа функций: ландшафт бесплодных земель (3 функции шума)
    //
    // Генерирует окончательный ландшафт бесплодных земель.
    //
    // Используя модуль масштаба/смещения, песок бесплодных земель значительно выравнивается,
    // затем высота песка снижается примерно до -1.0. Максимальное значение
    // модуль уплощенного песка и модуль утеса вносят свой вклад в
    // окончательная высота. Это приводит к тому, что песок появляется на низких высотах, так как
    // песок немного выше основания утеса.
    //
    // -1.0 представляет самую низкую высоту, а +1.0 представляет самую высокую
    // высоты.
    //

    // 1: [Модуль чешуйчатых песчаных дюн]: этот модуль масштаба/смещения значительно
    // выравнивает выходное значение из подгруппы badlands-sands и понижает
    // это значение близко к -1.0.
    let badlands_terrain_sb = ScaleBias::new(&badlands_sand)
        .set_scale(0.25)
        .set_bias(-0.75);

    // 2: [Модуль «Дюны и скалы»]: Этот модуль максимального значения заставляет дюны
    // чтобы появиться в низких областях и скалы, чтобы появиться в высоких областях.
    // Он делает это, выбирая максимум выходных значений из
    // модуль Scaled-Sand-Dunes и подгруппа Badlands-Cliffs.
    let badlands_terrain_ma: Max<[f64; 3]> = Max::new(&badlands_cliffs, &badlands_terrain_sb);

    // 3: [Группа Badlands-terrain]: кэширует выходное значение из дюн-и-
    // модуль скал. Это выходное значение для всего бесплодного ландшафта.
    // группа.
    let badlands_terrain: Cache<&Max<[f64; 3]>> = Cache::new(&badlands_terrain_ma);

    //////////////////////////////////////////////////// /////////////////////////
    // Группа функций: речные позиции
    //////////////////////////////////////////////////// /////////////////////////

    //////////////////////////////////////////////////// /////////////////////////
    // Подгруппа функций: позиции рек (7 функций шума)
    //
    // Эта подгруппа генерирует позиции на ривере.
    //
    // -1.0 представляет самую низкую высоту, а +1.0 представляет самую высокую
    // высоты.
    //

    // 1: [Модуль крупной реки]: эта функция ребристого мультифрактального шума
    // создает большие, глубокие реки.
    let river_positions_rm0 = RidgedMulti::new()
        .set_seed(*CURRENT_SEED + 100)
        .set_frequency(18.75)
        .set_lacunarity(*CONTINENT_LACUNARITY)
        .set_octaves(1);

    // 2: [Модуль большой реки-кривой]: этот модуль кривой применяет кривую к
    // выводим значение из модуля large-river-basis, чтобы хребты стали
    // инвертировано. Это создает реки. Эта кривая также сжимает край
    // реки, производящие резкий переход от суши к реке
    // нижний.
    let river_positions_cu0: Curve<[f64; 3]> = Curve::new(&river_positions_rm0);
    let river_positions_cu0 = river_positions_cu0
        .add_control_point(-2.000, 2.000)
        .add_control_point(-1.000, 1.000)
        .add_control_point(-0.125, 0.875)
        .add_control_point(0.000, -1.000)
        .add_control_point(1.000, -1.500)
        .add_control_point(2.000, -2.000);

    // 3: [Модуль малой реки]: эта функция ребристого мультифрактального шума
    // создает маленькие неглубокие реки.
    let river_positions_rm1 = RidgedMulti::new()
        .set_seed(*CURRENT_SEED + 101)
        .set_frequency(43.25)
        .set_lacunarity(*CONTINENT_LACUNARITY)
        .set_octaves(1);

    // 4: [Модуль Small-river-curve]: Этот модуль кривой применяет кривую к
    // выводим значение из модуля small-river-basis, чтобы гребни стали
    // инвертировано. Это создает реки. Эта кривая также сжимает край
    // реки, производящие резкий переход от суши к реке
    // нижний.
    let river_positions_cu1: Curve<[f64; 3]> = Curve::new(&river_positions_rm1);
    let river_positions_cu1 = river_positions_cu1
        .add_control_point(-2.000, 2.0000)
        .add_control_point(-1.000, 1.5000)
        .add_control_point(-0.125, 1.4375)
        .add_control_point(0.000, 0.5000)
        .add_control_point(1.000, 0.2500)
        .add_control_point(2.000, 0.0000);

    // 5: [Модуль комбинированных рек]: Этот модуль с минимальным значением вызывает небольшой
    // реки врезаться в большие реки. Это делается путем выбора
    // минимальные выходные значения из модуля large-river-curve и small-
    // модуль кривой реки.
    let river_positions_mi: Min<[f64; 3]> = Min::new(&river_positions_cu0, &river_positions_cu1);

    // 6: [Модуль искривленных рек]: Этот модуль турбулентности искажает выходное значение
    // из модуля комбинированных рек, который скручивает реки. Высота
    // шероховатость создает менее плавные реки.
    let river_positions_tu: Turbulence<&Min<[f64; 3]>> = Turbulence::<_>::new(&river_positions_mi)
        .set_seed(*CURRENT_SEED + 102)
        .set_frequency(9.25)
        .set_power(1.0 / 57.75)
        .set_roughness(6);

    // 7: [Группа River-positions]: Кэширует выходное значение из деформированного
    // модуль рек. Это выходное значение для всей реки.
    // группа позиций.
    let river_positions: Cache<&Turbulence<&Min<[f64; 3]>>> = Cache::new(&river_positions_tu);

    //////////////////////////////////////////////////// //////////////////////////
    // Группа функций: масштабированный горный рельеф
    //////////////////////////////////////////////////// //////////////////////////

    //////////////////////////////////////////////////// //////////////////////////
    // Подгруппа функций: масштабированный горный рельеф (6 функций шума)
    //
    // Эта подгруппа масштабирует выходное значение из группы горной местности
    // чтобы его можно было добавить к высоте, определяемой континентом-
    // группа определений.
    //
    // Эта подгруппа масштабирует выходное значение таким образом, чтобы оно почти всегда
    // положительный. Это сделано для того, чтобы не применялась отрицательная отметка.
    // к группе определения континента, предотвращая части этой группы от
    // с «впечатанными» в него негативными особенностями ландшафта.
    //
    // Выходное значение этой подгруппы модулей измеряется в планетарных
    // единицы высоты (-1,0 для самых нижних подводных траншей и +1,0 для
    // самые высокие горные вершины.)
    //

    // 1: [Base-scaled-mountainous-terrain module]: этот модуль масштаба/смещения
    // масштабирует выходное значение из группы горной местности так, чтобы
    // выходное значение измеряется в планетарных единицах высоты.
    let scaled_mountainous_terrain_sb0 = ScaleBias::new(&mountainous_terrain)
        .set_scale(0.125)
        .set_bias(0.125);

    // 2: [модуль базовой пиковой модуляции]: на этом этапе большинство горных вершин имеют
    // примерно такая же высота. Этот модуль BasicMulti создает некоторые
    // случайные значения, которые будут использоваться последующими шумовыми функциями для случайного
    // изменить высоту горных вершин.
    let scaled_mountainous_terrain_fb = Fbm::new()
        .set_seed(*CURRENT_SEED + 110)
        .set_frequency(14.5)
        .set_persistence(0.5)
        .set_lacunarity(*MOUNTAIN_LACUNARITY)
        .set_octaves(6);

    // 3: [Модуль пиковой модуляции]: Этот модуль экспоненциальной кривой применяет
    // экспоненциальная кривая к выходному значению от base-peak-modulation
    // модуль. Это дает небольшое количество высоких значений и гораздо большее
    // количество младших значений. Это означает, что будет несколько пиков с большим
    // более высокие отметки, чем большинство пиков, что делает местность
    // функции более разнообразны.
    let scaled_mountainous_terrain_ex: Exponent<[f64; 3]> =
        Exponent::new(&scaled_mountainous_terrain_fb);
    let scaled_mountainous_terrain_ex = scaled_mountainous_terrain_ex.set_exponent(1.25);

    // 4: [Модуль масштабированной пиковой модуляции]: Этот модуль масштабирования/смещения изменяет
    // диапазон выходного значения модуля пиковой модуляции, чтобы он мог
    // использоваться как модулятор для модуля множителя пиковой высоты. это
    // важно, чтобы это выходное значение было не намного меньше 1,0.
    let scaled_mountainous_terrain_sb1 = ScaleBias::new(&scaled_mountainous_terrain_ex)
        .set_scale(0.25)
        .set_bias(1.0);

    // 5: [Модуль множителя высоты пика]: Этот модуль множителя модулирует
    // высоты горных вершин от base-scaled-mountainous-terrain
    // модуль, использующий выходное значение из модуля масштабируемой пиковой модуляции.
    let scaled_mountainous_terrain_mu = Multiply::new(
        &scaled_mountainous_terrain_sb0,
        &scaled_mountainous_terrain_sb1,
    );

    // 6: [Группа масштабируемой горной местности]: кэширует выходное значение из
    // модуль множителя высоты пика. Это выходное значение для
    // вся группа масштабируемой гористой местности.
    let scaled_mountainous_terrain = Cache::new(&scaled_mountainous_terrain_mu);

    //////////////////////////////////////////////////// //////////////////////////
    // Группа функций: масштабируемая холмистая местность
    //////////////////////////////////////////////////// //////////////////////////

    //////////////////////////////////////////////////// //////////////////////////
    // Подгруппа функций: масштабированная холмистая местность (6 функций шума)
    //
    // Эта подгруппа масштабирует выходное значение из группы холмистой местности, поэтому
    // что его можно добавить к высоте, определяемой континентом-
    // группа определений. Величина масштабирования, применяемая к холмам, составляет половину
    // величина масштабирования, примененная к группе масштабируемой горной местности.
    //
    // Эта подгруппа масштабирует выходное значение таким образом, чтобы оно почти всегда
    // положительный. Это сделано для того, чтобы отрицательные отметки не применялись к
    // группа определения континента, предотвращающая части континента-
    // группа определений из-за того, что в нее «впечатаны» отрицательные особенности ландшафта.
    //
    // Выходное значение этой подгруппы модулей измеряется в планетарных
    // единицы высоты (-1,0 для самых нижних подводных траншей и +1,0 для
    // самые высокие горные вершины.)
    //

    // 1: [Модуль базового масштаба холмистой местности]: этот модуль масштаба/смещения масштабирует
    // выходное значение из группы холмистой местности, чтобы это выходное значение было
    // измеряется в планетарных единицах высоты.
    let scaled_hilly_terrain_sb0 = ScaleBias::new(&hilly_terrain)
        .set_scale(0.0625)
        .set_bias(0.0625);

    // 2: [модуль Base-hilltop-modulation]: на этом этапе большинство вершин холмов имеют
    // примерно такая же высота. Этот модуль BasicMulti создает некоторые
    // случайные значения, которые будут использоваться последующими шумовыми функциями для
    // случайным образом меняем высоты вершин холмов.
    let scaled_hilly_terrain_fb = Fbm::new()
        .set_seed(*CURRENT_SEED + 120)
        .set_frequency(13.5)
        .set_persistence(0.5)
        .set_lacunarity(*HILLS_LACUNARITY)
        .set_octaves(6);

    // 3: [Модуль Hilltop-modulation]: Этот модуль экспоненциальной кривой применяет
    // экспоненциальная кривая к выходному значению от base-hilltop-modulation
    // модуль. Это дает небольшое количество высоких значений и гораздо большее
    // количество младших значений. Это означает, что будет несколько вершин холмов с
    // гораздо более высокие возвышения, чем большинство вершин холмов, что делает
    // особенности ландшафта более разнообразны.
    let scaled_hilly_terrain_ex: Exponent<[f64; 3]> = Exponent::new(&scaled_hilly_terrain_fb);
    let scaled_hilly_terrain_ex = scaled_hilly_terrain_ex.set_exponent(1.25);

    // 4: [Модуль масштабной модуляции на вершине холма]: этот модуль масштаба/смещения изменяет
    // диапазон выходного значения модуля модуляции вершины холма, чтобы
    // его можно использовать как модулятор для модуля множителя высоты холма.
    // Важно, чтобы это выходное значение было не намного меньше 1.0.
    let scaled_hilly_terrain_sb1 = ScaleBias::new(&scaled_hilly_terrain_ex)
        .set_scale(0.5)
        .set_bias(1.5);

    // 5: [Модуль множителя высоты холма]: Этот модуль множителя модулирует
    // высота вершин холмов из модуля base-scaled-hilly-terrain
    // используя выходное значение из модуля Scaled-Hilltop-Modulation.
    let scaled_hilly_terrain_mu =
        Multiply::new(&scaled_hilly_terrain_sb0, &scaled_hilly_terrain_sb1);

    // 6: [Группа холмистой местности]: кэширует выходное значение из
    // модуль множителя высоты холма. Это выходное значение для всего
    // группа масштабируемой холмистой местности.
    let scaled_hilly_terrain = Cache::new(&scaled_hilly_terrain_mu);

    //////////////////////////////////////////////////// //////////////////////////
    // Группа функций: равнинный ландшафт в масштабе
    //////////////////////////////////////////////////// //////////////////////////

    //////////////////////////////////////////////////// //////////////////////////
    // Подгруппа функций: масштабированный ландшафт равнин (2 функции шума)
    //
    // Эта подгруппа масштабирует выходное значение из группы равнин и местности, поэтому
    // что его можно добавить к высотам, определенным континентом-
    // группа определений.
    //
    // Эта подгруппа масштабирует выходное значение таким образом, чтобы оно почти всегда
    // положительный. Это сделано для того, чтобы отрицательные отметки не применялись к
    // группа определения континента, предотвращающая части континента-
    // группа определений из-за того, что в нее «впечатаны» отрицательные особенности ландшафта.
    //
    // Выходное значение этой подгруппы модулей измеряется в планетарных
    // единицы высоты (-1,0 для самых нижних подводных траншей и +1,0 для
    // самые высокие горные вершины.)
    //

    // 1: [Модуль Scaled-plains-terrain]: Этот модуль масштабирования/смещения значительно
    // выравнивает выходное значение равнинного ландшафта. Это выходное значение
    // измеряется в планетарных единицах высоты.
    let scaled_plains_terrain_sb0 = ScaleBias::new(&plains_terrain)
        .set_scale(0.00390625)
        .set_bias(0.0078125);

    // 2: [Группа Scaled-plains-terrain]: кэширует выходное значение из
    // модуль масштабируемой равнины. Это выходное значение для всего
    // группа масштабируемых равнин-территории.
    let scaled_plains_terrain = Cache::new(&scaled_plains_terrain_sb0);

    //////////////////////////////////////////////////// //////////////////////////
    // Группа функций: масштабированный ландшафт бесплодных земель
    //////////////////////////////////////////////////// //////////////////////////

    //////////////////////////////////////////////////// //////////////////////////
    // Подгруппа функций: масштабированный ландшафт бесплодных земель (2 функции шума)
    //
    // Эта подгруппа масштабирует выходное значение из группы badlands-terrain, поэтому
    // что его можно добавить к высотам, определенным континентом-
    // группа определений.
    //
    // Эта подгруппа масштабирует выходное значение таким образом, чтобы оно почти всегда
    // положительный. Это сделано для того, чтобы отрицательные отметки не применялись к
    // группа определения континента, запрещающая части определения континента
    // группа из-за того, что в нее «впечатаны» отрицательные особенности рельефа.
    //
    // Выходное значение этой подгруппы модулей измеряется в планетарных
    // единицы высоты (-1,0 для самых нижних подводных траншей и +1,0 для
    // самые высокие горные вершины.)
    //

    // 1: [Модуль Scaled-badlands-terrain]: Этот модуль масштаба/смещения масштабирует
    // выводим значение из группы badlands-terrain, чтобы оно было измерено
    // в планетарных единицах высоты.
    let scaled_badlands_terrain_sb = ScaleBias::new(&badlands_terrain)
        .set_scale(0.0625)
        .set_bias(0.0625);

    // 2: [Группа Scaled-badlands-terrain]: кэширует выходное значение из
    // модуль Scaled-Badlands-Terrain. Это выходное значение для
    // вся группа Scaled-Badlands-Terrain.
    let scaled_badlands_terrain: Cache<&ScaleBias<[f64; 3]>> =
        Cache::new(&scaled_badlands_terrain_sb);

    //////////////////////////////////////////////////// //////////////////////////
    // Группа функций: конечная планета
    //////////////////////////////////////////////////// //////////////////////////

    //////////////////////////////////////////////////// //////////////////////////
    // Подгруппа функций: континентальный шельф (6 функций шума)
    //
    // Эта подгруппа модулей создает континентальные шельфы.
    //
    // Выходное значение из этой подгруппы модулей измеряется в планетарных
    // единицы высоты (-1,0 для самых нижних подводных траншей и +1,0 для
    // самые высокие горные вершины.)
    //

    // 1: [Модуль создания полки]: Этот модуль террасирования применяет
    // кривая к группе определения континента на указанном уровне полки.
    // Эта терраса становится континентальным шельфом. Обратите внимание, что это террасирование
    // модуль также помещает еще одну террасу ниже континентального шельфа около -1,0.
    // Дно этой террасы определяется как дно океана;
    // последующие шумовые функции позже добавят океанические впадины на дно
    // океан.
    let continental_shelf_te: Terrace<[f64; 3]> = Terrace::new(&continent_def)
        .add_control_point(-1.0)
        .add_control_point(-0.75)
        .add_control_point(*SHELF_LEVEL)
        .add_control_point(1.0);

    // 2: [Модуль зажима морского дна]: этот модуль зажима фиксирует вывод
    // значение из модуля Shelf-Creator, чтобы его возможный диапазон был от
    // дна океана до уровня моря. Это сделано потому, что эта подгруппа
    // беспокоит только океан.
    let continental_shelf_cl: Clamp<[f64; 3]> =
        Clamp::new(&continental_shelf_te).set_bounds(-0.75, *SEA_LEVEL);

    // 3: [Модуль океанического желоба]: эта функция ребристого мультифрактального шума
    // генерирует некоторый когерентный шум, который будет использоваться для генерации океанического
    // траншеи. Гребни представляют дно траншей.
    let continental_shelf_rm = RidgedMulti::new()
        .set_seed(*CURRENT_SEED + 130)
        .set_frequency(*CONTINENT_FREQUENCY * 4.375)
        .set_lacunarity(*CONTINENT_LACUNARITY)
        .set_octaves(16);

    // 4: [Модуль океанической впадины]: Этот модуль масштаба/смещения инвертирует хребты
    // из модуля oceanic-trench-basis, чтобы хребты стали траншеями.
    // Эта шумовая функция также уменьшает глубину траншей, чтобы их
    // глубины измеряются в планетарных единицах высоты.
    let continental_shelf_sb: ScaleBias<[f64; 3]> = ScaleBias::new(&continental_shelf_rm);
    let continental_shelf_sb = continental_shelf_sb.set_scale(-0.125).set_bias(-0.125);

    // 5: [Модуль шельфа и траншей]: Этот дополнительный модуль добавляет океанический
    // траншеи к модулю зажатого морского дна.
    let continental_shelf_ad: Add<[f64; 3]> =
        Add::new(&continental_shelf_sb, &continental_shelf_cl);

    // 6: [Подгруппа Continental-shelf]: Кэширует выходное значение с полки-
    // и-траншейный модуль.
    let continental_shelf: Cache<Add<[f64; 3]>> = Cache::new(continental_shelf_ad);

    //////////////////////////////////////////////////// //////////////////////////
    // Группа функций: высоты базового континента (3 функции шума)
    //
    // Эта подгруппа генерирует базовые высоты для континентов перед
    // добавлены особенности рельефа.
    //
    // Выходное значение этой подгруппы модулей измеряется в планетарных
    // единицы высоты (-1,0 для самых нижних подводных траншей и +1,0 для
    // самые высокие горные вершины.)
    //

    // 1: [Base-scaled-continent-elevations module]: этот модуль масштаба/смещения
    // масштабирует выходное значение из группы определения континента так, чтобы оно
    // измеряется в планетарных единицах высоты.
    let base_continent_elev_sb: ScaleBias<[f64; 3]> = ScaleBias::new(&continent_def)
        .set_scale(*CONTINENT_HEIGHT_SCALE)
        .set_bias(0.0);

    // 2: [модуль базового континента с океанами]: этот модуль выбора применяет
    // отметки континентальных шельфов до базовых отметок
    // континент. Он делает это, выбирая выходное значение из
    // подгруппа континентального шельфа, если соответствующее выходное значение из
    // группа определения континента находится ниже уровня полки. В противном случае это
    // выбирает выходное значение из высоты континента в базовом масштабе
    // модуль.
    let base_continent_elev_se: Select<[f64; 3]> =
        Select::new(&base_continent_elev_sb, &continental_shelf, &continent_def)
            .set_bounds(*SHELF_LEVEL - 1000.0, *SHELF_LEVEL)
            .set_falloff(0.03125);

    // 3: [Подгруппа высоты континента]: кэширует выходное значение из
    // модуль базового континента с океанами.
    let base_continent_elev = Cache::new(&base_continent_elev_se);

    //////////////////////////////////////////////////// //////////////////////////
    // Подгруппа функций: континенты с равнинами (2 функции шума)
    //
    // Эта подгруппа применяет группу Scaled-Plains-Terrain к базовому
    // подгруппа высоты континента.
    //
    // Выходное значение этой подгруппы модулей измеряется в планетарных
    // единицы высоты (-1,0 для самых нижних подводных траншей и +1,0 для
    // самые высокие горные вершины.)
    //

    // 1: [Модуль континентов с равнинами]: Этот дополнительный модуль добавляет
    // группу равнины-территории в подгруппу основания-континента-высоты.
    let continents_with_plains_ad: Add<[f64; 3]> =
        Add::new(&base_continent_elev, &scaled_plains_terrain);

    // 2: [Подгруппа Continents-with-plains]: кэширует выходное значение из
    // модуль континентов с равнинами.
    let continents_with_plains: Cache<&Add<[f64; 3]>> = Cache::new(&continents_with_plains_ad);

    //////////////////////////////////////////////////// //////////////////////////
    // Подгруппа функций: континенты с холмами (3 функции шума)
    //
    // Эта подгруппа применяет группу холмистой местности к континентам-
    // подгруппа with-plains.
    //
    // Выходное значение этой подгруппы модулей измеряется в планетарных
    // единицы высоты (-1,0 для самых нижних подводных траншей и +1,0 для
    // самые высокие горные вершины.)
    //

    // 1: [Модуль континентов с холмами]: Этот дополнительный модуль добавляет
    // группа холмистой местности в подгруппу основание-континент-высота.
    let continents_with_hills_ad = Add::new(&base_continent_elev, &scaled_hilly_terrain);

    // 2: [Select-high-elevations module]: Этот селекторный модуль гарантирует, что
    // холмы появляются только на больших высотах. Это делается путем выбора
    // выводим значение из модуля континент-с-холмами, если соответствующий
    // выходное значение из группы определения типа местности выше определенного
    // ценность. В противном случае он выбирает выходное значение из континентов-с-
    // подгруппа равнин.
    let continents_with_hills_se = Select::new(
        &continents_with_plains,
        &continents_with_hills_ad,
        &terrain_type_def,
    )
    .set_bounds(1.0 - *HILLS_AMOUNT, 1001.0 - *HILLS_AMOUNT)
    .set_falloff(0.25);

    // 3: [Подгруппа континентов с холмами]: кэширует выходное значение из
    // модуль select-high-elevations.
    let continents_with_hills = Cache::new(&continents_with_hills_se);

    //////////////////////////////////////////////////// //////////////////////////
    // Подгруппа функций: континенты с горами (5 шумовых функций)
    //
    // Эта подгруппа применяет группу масштабируемой горной местности к
    // подгруппа континентов-с-холмами.
    //
    // Выходное значение этой подгруппы модулей измеряется в планетарных
    // единицы высоты (-1,0 для самых нижних подводных траншей и +1,0 для
    // самые высокие горные вершины.)
    //

    // 1: [Модуль континентов и гор]: этот дополнительный модуль добавляет
    // группа масштабируемого-горного-территория к базовой-континентальной-высоте
    // подгруппа.
    let continents_with_mountains_ad0 = Add::new(&base_continent_elev, &scaled_mountainous_terrain);

    // 2: [Модуль увеличения высоты горы]: этот модуль кривой применяет кривую
    // к выходному значению из группы определения континента. Это модифицированное
    // выходное значение используется последующей функцией шума для добавления дополнительных
    // высота до гор на основе текущей высоты континента.
    // чем выше высота континента, тем выше горы.
    let continents_with_mountains_cu = Curve::new(&continent_def)
        .add_control_point(-1.0, -0.0625)
        .add_control_point(0.0, 0.0000)
        .add_control_point(1.0 - *MOUNTAINS_AMOUNT, 0.0625)
        .add_control_point(1.0, 0.2500);

    // 3: [Add-increased-mountain-heights module]: Этот дополнительный модуль добавляет
    // модуль увеличенных горных высот к модулю континентов и гор.
    // Самые высокие континенты теперь имеют самые высокие горы.
    let continents_with_mountains_ad1 = Add::new(
        &continents_with_mountains_ad0,
        &continents_with_mountains_cu,
    );

    // 4: [Select-high-elevations module]: Этот селекторный модуль гарантирует, что
    // горы появляются только на больших высотах. Это делается путем выбора
    // выводим значение из модуля континент-с-горами, если
    // соответствующее выходное значение из группы определения типа местности
    // выше определенного значения. В противном случае он выбирает выходное значение из
    // подгруппа континентов-с-холмами. Обратите внимание, что континенты-с-холмами
    // подгруппа также содержит равнинный ландшафт.
    let continents_with_mountains_se = Select::new(
        &continents_with_hills,
        &continents_with_mountains_ad1,
        &terrain_type_def,
    )
    .set_bounds(1.0 - *MOUNTAINS_AMOUNT, 1001.0 - *MOUNTAINS_AMOUNT)
    .set_falloff(0.25);

    // 5: [Подгруппа континентов-с-горами]: кэширует выходное значение из
    // модуль select-high-elevations.
    let continents_with_mountains: Cache<&Select<[f64; 3]>> =
        Cache::new(&continents_with_mountains_se);

    //////////////////////////////////////////////////// //////////////////////////
    // Подгруппа функций: континенты с бесплодными землями (5 шумовых функций)
    //
    // Эта подгруппа применяет группу Scaled-Badlands-Terrain к
    // подгруппа континентов-с-горами.
    //
    // Выходное значение этой подгруппы модулей измеряется в планетарных
    // единицы высоты (-1,0 для самых нижних подводных траншей и +1,0 для
    // самые высокие горные вершины.)
    //

    // 1: [Модуль Badlands-positions]: Этот модуль BasicMulti генерирует некоторые
    // случайный шум, который используется последующими шумовыми функциями для указания
    // локации бесплодных земель.
    let continents_with_badlands_bm = Fbm::new()
        .set_seed(*CURRENT_SEED + 140)
        .set_frequency(16.5)
        .set_persistence(0.5)
        .set_lacunarity(*CONTINENT_LACUNARITY)
        .set_octaves(2);

    // 2: [Модуль континентов и бесплодных земель]: этот дополнительный модуль добавляет
    // группа Scaled-Badlands-Terrain к Base-Continent-Elevation
    // подгруппа.
    let continents_with_badlands_ad = Add::new(&base_continent_elev, &scaled_badlands_terrain);

    // 3: [Модуль Select-badlands-positions]: Этот модуль селектора размещает
    // бесплодные земли в случайных точках на континентах на основе шума BasicMulti
    // генерируется модулем badlands-positions. Для этого он выбирает
    // выходное значение из модуля континентов и бесплодных земель, если соответствующий
    // выходное значение модуля badlands-position больше, чем
    // указанное значение. В противном случае этот селекторный модуль выбирает выходное значение
    // из подгруппы континентов-с-горами. Существует также широкий
    // переход между этими двумя шумовыми функциями, чтобы бесплодные земли могли смешаться
    // в остальную часть местности на континентах.
    let continents_with_badlands_se = Select::new(
        &continents_with_mountains,
        &continents_with_badlands_ad,
        &continents_with_badlands_bm,
    )
    .set_bounds(1.0 - *BADLANDS_AMOUNT, 1001.0 - *BADLANDS_AMOUNT)
    .set_falloff(0.25);

    // 4: [Модуль Apply-badlands]: Этот модуль максимального значения вызывает бесплодные земли
    // "выпирать" из остального ландшафта. Это достигается за счет обеспечения
    // что только максимум выходных значений с континентов-с-
    // подгруппа гор и модули select-badlands-positions вносят свой вклад
    // к выходному значению этой подгруппы. Одним из побочных эффектов этого процесса является
    // что бесплодные земли не появятся в гористой местности.
    let continents_with_badlands_ma =
        Max::new(&continents_with_mountains, &continents_with_badlands_se);

    // 5: [Подгруппа Continents-with-badlands]: кэширует выходное значение из
    // модуль применения бесплодных земель.
    let continents_with_badlands = Cache::new(&continents_with_badlands_ma);

    //////////////////////////////////////////////////// //////////////////////////
    // Подгруппа функций: континенты с реками (4 функции шума)
    //
    // Эта подгруппа применяет группу речных позиций к континентам-с-
    // подгруппа бесплодных земель.
    //
    // Выходное значение этой подгруппы модулей измеряется в планетарных
    // единицы высоты (-1,0 для самых нижних подводных траншей и +1,0 для
    // самые высокие горные вершины.)
    //

    // 1: [Модуль Scaled-rivers]: Этот модуль масштабирования/смещения масштабирует выходное значение
    // из группы речных позиций, чтобы она измерялась в планетарных
    // единицы высоты и имеет отрицательное значение; это необходимо для шага 2.
    let continents_with_rivers_sb = ScaleBias::new(&river_positions)
        .set_scale(*RIVER_DEPTH / 2.0)
        .set_bias(-*RIVER_DEPTH / 2.0);

    // 2: [Модуль добавления рек к континентам]: Этот дополнительный модуль добавляет
    // реки в подгруппу континентов-с-бесплодными землями. Потому что масштаб-
    // модуль рек выводит только отрицательное значение, модуль масштабируемых рек
    // вырезает реки из местности.
    let continents_with_rivers_ad = Add::new(&continents_with_badlands, &continents_with_rivers_sb);

    // 3: [Модуль смешанных рек с континентами]: этот модуль выбора выводит
    // полноводные реки вблизи уровня моря и более мелкие реки на возвышенностях. Это
    // делает это, выбирая выходное значение из континентов-с-
    // подгруппа бесплодных земель, если соответствующее выходное значение из
    // подгруппа континентов с бесплодными землями находится далеко от уровня моря. В противном случае,
    // этот селекторный модуль выбирает выходное значение из списка add-rivers-to-
    // модуль континентов.
    let continents_with_rivers_se = Select::new(
        &continents_with_badlands,
        &continents_with_rivers_ad,
        &continents_with_badlands,
    )
    .set_bounds(*SEA_LEVEL, *CONTINENT_HEIGHT_SCALE + *SEA_LEVEL)
    .set_falloff(*CONTINENT_HEIGHT_SCALE - *SEA_LEVEL);

    // 4: [Подгруппа континентов с реками]: кэширует выходное значение из
    // модуль смешанных рек и континентов.
    let continents_with_rivers: Cache<&Select<[f64; 3]>> = Cache::new(&continents_with_rivers_se);

    //////////////////////////////////////////////////// //////////////////////////
    // Подгруппа функций: немасштабированная конечная планета (1 шумовая функция)
    //
    // Эта подгруппа просто кэширует выходное значение с континента-с-
    // подгруппа рек, вносящая вклад в итоговое выходное значение.
    //

    // 1: [Unscaled-final-planet subgroup]: кэширует выходное значение из
    // подгруппа континент-с-реками.
    let unscaled_final_planet: Cache<&Cache<&Select<[f64; 3]>>> =
        Cache::new(&continents_with_rivers);

    fn build_terrain_gradient(g: ColorGradient) -> ColorGradient {
        g.clear_gradient()
            .add_gradient_point(-1.00, [0, 0, 0, 255])
            .add_gradient_point(-256.0 / 16384.0, [6, 58, 127, 255])
            .add_gradient_point(-1.0 / 16384.0, [14, 112, 192, 255])
            .add_gradient_point(0.0, [70, 120, 60, 255])
            .add_gradient_point(1024.0 / 16384.0, [110, 140, 75, 255])
            .add_gradient_point(2048.0 / 16384.0, [160, 140, 111, 255])
            .add_gradient_point(3072.0 / 16384.0, [184, 163, 141, 255])
            .add_gradient_point(4096.0 / 16384.0, [128, 128, 128, 255])
            .add_gradient_point(5632.0 / 16384.0, [128, 128, 128, 255])
            .add_gradient_point(6144.0 / 16384.0, [250, 250, 250, 255])
            .add_gradient_point(1.0, [255, 255, 255, 255])
    }

    let noise_map = PlaneMapBuilder::new(&unscaled_final_planet)
        .set_size(1024, 1024)
        .set_x_bounds(-2.0, 2.0)
        .set_y_bounds(-2.0, 2.0)
        .build();

        noise_map

    // ImageRenderer::new()
    //     .set_gradient(build_terrain_gradient(ColorGradient::new()))
    //     .render(&noise_map)
    //     .write_to_file("unscaledFinalPlanet.png");

    // let noise_map = PlaneMapBuilder::new(&unscaled_final_planet)
    //     .set_size(1024, 1024)
    //     .set_x_bounds(-0.5, 0.5)
    //     .set_y_bounds(-0.5, 0.5)
    //     .build();

    // ImageRenderer::new()
    //     .set_gradient(build_terrain_gradient(ColorGradient::new()))
    //     .render(&noise_map)
    //     .write_to_file("unscaledFinalPlanet_4x_zoom.png");

    // let noise_map = PlaneMapBuilder::new(&unscaled_final_planet)
    //     .set_size(1024, 1024)
    //     .set_x_bounds(-0.0, 0.25)
    //     .set_y_bounds(-0.125, 0.125)
    //     .build();

    // ImageRenderer::new()
    //     .set_gradient(build_terrain_gradient(ColorGradient::new()))
    //     .render(&noise_map)
    //     .write_to_file("unscaledFinalPlanet_16x_zoom.png");

    // ImageRenderer::new()
    //     .set_gradient(build_terrain_gradient(ColorGradient::new()))
    //     .render(
    //         &SphereMapBuilder::new(&unscaled_final_planet)
    //             .set_size(1024, 1024)
    //             .set_bounds(-90.0, 90.0, -180.0, 180.0)
    //             .build(),
    //     )
    //     .write_to_file("unscaledFinalPlanet_sphere.png");
}
