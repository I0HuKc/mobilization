pub mod continent_definition {
    //! Модуль определения континентов

    use noise::{
        Add, Billow, Blend, Cache, Clamp, Constant, Curve, Exponent, Fbm, Max, Min, MultiFractal,
        Multiply, RidgedMulti, ScaleBias, Seedable, Select, Terrace, Turbulence, Worley,
    };

    use crate::resource::world::{
        BADLANDS_LACUNARITY, BADLANDS_TWIST, CONTINENT_FREQUENCY, CONTINENT_LACUNARITY,
        CURRENT_SEED, HILLS_LACUNARITY, HILLS_TWIST, MOUNTAINS_TWIST, MOUNTAIN_GLACIATION,
        MOUNTAIN_LACUNARITY, PLAINS_LACUNARITY, SEA_LEVEL, SHELF_LEVEL, TERRAIN_OFFSET,
    };

    #[allow(dead_code)]
    fn base_continent_definition() {
        /////////////////////////////////////////////////////////////////////////////
        // Группа шагов: ОПРЕДЕЛЕНИЕ КОНТИНЕНТОВ
        /////////////////////////////////////////////////////////////////////////////

        /////////////////////////////////////////////////////////////////////////////
        // Подгруппа: Базовое определение континента
        /////////////////////////////////////////////////////////////////////////////
        //
        // В процессе выполнения шагов определяю позиции и базовые отметки
        // континентов в мире.
        //
        // «Базовая отметка» — это отметка местности до того, как какая-либо местность
        // объекты (горы, холмы и т. д.) размещаются на этой местности.
        //
        // -1.0 представляет самую низкую высоту, а +1.0 представляет самую высокую высоту.
        /////////////////////////////////////////////////////////////////////////////
        //
        // Шаг 1. Генерация континентов.
        // В функцию шума ставлю большое кол-во оклав, поэтому детали будут видны на
        // высоких уровнях масштабирования.
        let base_continent_def_fb0 = Fbm::new()
            .set_seed(*CURRENT_SEED)
            .set_frequency(*CONTINENT_FREQUENCY)
            .set_persistence(0.5)
            .set_lacunarity(*CONTINENT_LACUNARITY)
            .set_octaves(14);

        // Шаг 2. Определения положения горных хребтов.
        // Использую функцию шума для изменения здачения полученного на шаге 1,
        // что позволяет отображать более высокие значения ближе к уровню моря.
        let base_continent_def_cu: Curve<[f64; 3]> = Curve::new(&base_continent_def_fb0);
        let base_continent_def_cu: Curve<[f64; 3]> = base_continent_def_cu
            .add_control_point(-2.0000 + *SEA_LEVEL, -1.625 + *SEA_LEVEL)
            .add_control_point(-1.0000 + *SEA_LEVEL, -1.375 + *SEA_LEVEL)
            .add_control_point(0.0000 + *SEA_LEVEL, -0.375 + *SEA_LEVEL)
            .add_control_point(0.0625 + *SEA_LEVEL, 0.125 + *SEA_LEVEL)
            .add_control_point(0.1250 + *SEA_LEVEL, 0.250 + *SEA_LEVEL)
            .add_control_point(0.2500 + *SEA_LEVEL, 1.000 + *SEA_LEVEL)
            .add_control_point(0.5000 + *SEA_LEVEL, 0.250 + *SEA_LEVEL)
            .add_control_point(0.7500 + *SEA_LEVEL, 0.250 + *SEA_LEVEL)
            .add_control_point(1.0000 + *SEA_LEVEL, 0.500 + *SEA_LEVEL)
            .add_control_point(2.0000 + *SEA_LEVEL, 0.500 + *SEA_LEVEL);

        // Шаг 3. Использую высокочастотный модуль BasicMulti с последующими
        // шумовыми функциями для вырезания фрагментов из горных хребтов,
        // чтобы горные хребты не были полностью непроходимыми.
        let base_continent_def_fb1 = Fbm::new()
            .set_seed(*CURRENT_SEED + 1)
            .set_frequency(*CONTINENT_FREQUENCY * 4.34375)
            .set_persistence(0.5)
            .set_lacunarity(*CONTINENT_LACUNARITY)
            .set_octaves(11);

        // Шаг 4. Масштабирую полученное значение на предыдущем шаге (обычно близкое к 1.0).
        let base_continent_def_sb: ScaleBias<[f64; 3]> = ScaleBias::new(&base_continent_def_fb1);
        let base_continent_def_sb: ScaleBias<[f64; 3]> =
            base_continent_def_sb.set_scale(0.375).set_bias(0.625);

        // Шаг 5. Вырезание континентов.
        // Из полученных значений на шаге 2, вырезаю куски с минимальными значениями.
        // Это гарантирует, что только минимум выходных значений от шага 3 и шага 2
        // вносят свой вклад в вывод значений из этой функции.
        // В большинстве случаев будет выбираться выходное значение полученное на шаге 2,
        // так как выходно е значение масштабируемого резчика обычно близко к 1,0.
        // Время от времени, результат шага 4 будет меньше, чем вывод значение из мшага 2.
        let base_continent_def_mi: Min<[f64; 3]> =
            Min::new(&base_continent_def_sb, &base_continent_def_cu);

        // Шаг 6. Скрепление континентов.
        // Изменяю полученные значения на шаге 1, чтобы гарантировать,
        // что выходное значение этой функции между -1,0 и 1,0.
        let base_continent_def_cl: Clamp<[f64; 3]> =
            Clamp::new(&base_continent_def_mi).set_bounds(-1.0, 1.0);

        // Финальный шаг подгруппы.
        // Кеширую резьтат выполнения предыдущего шага.
        let base_continent_def: Cache<Clamp<[f64; 3]>> = Cache::new(base_continent_def_cl);

        /////////////////////////////////////////////////////////////////////////////
        // Подгруппа: Определение континента
        /////////////////////////////////////////////////////////////////////////////
        //
        // В процессе выполнения шагов искажаю выходное значение полученное в
        // результате выполнения функции `base_continent_definition`,
        // создавая более реалистичный ландшафт.
        //
        // Деформация базовых континентов создает более бугристую местность
        // с скалами и трещинами.
        //
        // -1.0 представляет самую низкую высоту, а +1.0 представляет самую высокую высоту.
        /////////////////////////////////////////////////////////////////////////////

        // Шаг 1. Используя грубую турбулентность искажаю значение полученное при базовом
        // определении континентов, добавляя некоторые случайные грубые детали к нему.
        let continent_def_tu0 = Turbulence::<_>::new(&base_continent_def)
            .set_seed(*CURRENT_SEED + 10)
            .set_frequency(*CONTINENT_FREQUENCY * 15.25)
            .set_power(*CONTINENT_FREQUENCY / 113.75)
            .set_roughness(13);

        // Шаг 2. Используя промежуточную турбулентность искажаю значения
        // полученные на шаге 1. Применяю более высокие частоты, но меньшую мощность,
        // чем в шаге 1, что позволяет добавить промежуточные детали.
        let continent_def_tu1 = Turbulence::<_>::new(continent_def_tu0)
            .set_seed(*CURRENT_SEED + 11)
            .set_frequency(*CONTINENT_FREQUENCY * 47.25)
            .set_power(*CONTINENT_FREQUENCY / 433.75)
            .set_roughness(12);

        // Шаг 3. Деформирование базового определения континентов.
        // Так же использую турбулентность, искажаю результат шага 2.
        // Турбулентность имеет более высокую частоту, но меньшую мощность, чем
        // в шаге 2, что позволяет добавить мелкие детали.
        let continent_def_tu2 = Turbulence::<_>::new(continent_def_tu1)
            .set_seed(*CURRENT_SEED + 12)
            .set_frequency(*CONTINENT_FREQUENCY * 95.25)
            .set_power(*CONTINENT_FREQUENCY / 1019.75)
            .set_roughness(11);

        // Шаг 4. Выборочная турбулентность.
        // Ко всей подгруппе определеных базового континентов, применяю турбулентность,
        // что позволяет получить более бурные береговые линии. Селекторная функция выбирает
        // выходные значения из (недеформированной) подгруппы базово определенных континентов и шага 3.
        // На их основе выводится значение из (недеформированной) подгруппы определения базового континента.
        // Граница выделения находится вблизи уровня моря и имеет относительно гладкий переход.
        // Фактически, искажаются только высокие области базово определенных континентов.
        // Подводные и рибрежные зоны остаются незатронутыми.
        let continent_def_se =
            Select::new(&base_continent_def, &continent_def_tu2, &base_continent_def)
                .set_bounds(*SEA_LEVEL - 0.0375, *SEA_LEVEL + 1000.0375)
                .set_falloff(0.0625);

        // Финальный шаг подгруппы.
        // Кеширую полученный результат.
        // Это выходное значение для всей группы `ОПРЕДЕЛЕНИЕ КОНТИНЕНТОВ`.
        let continent_def = Cache::new(&continent_def_se);

        /////////////////////////////////////////////////////////////////////////////
        // Группа шагов: ОПРЕДЕЛЕНИЕ ТИПА МЕСТНОСТИ
        /////////////////////////////////////////////////////////////////////////////

        /////////////////////////////////////////////////////////////////////////////
        // Подгруппа: Определение типа местности
        /////////////////////////////////////////////////////////////////////////////
        //
        // В результате выполнения шагов, определяю положение типов местности в мире.
        // Типы местности создаются, в порядке возрастания шероховатости,
        // равнины, холмы и горы.
        //
        // Выходное значение этой подгруппы основано на выходном значении
        // результатов выполнения группы `ОПРЕДЕЛЕНИЕ КОНТИНЕНТОВ`
        //
        // -1.0 представляет самые гладкие типы местности (равнины и под водой) и
        // +1.0 представляет самые пересеченные типы местности (горы).
        /////////////////////////////////////////////////////////////////////////////

        // Шаг 1. Искривление континентов.
        // Используя турбулентность немного искажаю результат выполнения
        // группы `ОПРЕДЕЛЕНИЕ КОНТИНЕНТОВ`. Это позволяет предотвратить воявление
        // грубой местности исключительно на возвышенностях. Грубе области ландшафта теперь
        // могут появляться в океане, создавая скалистые острова и фьорды.
        let terrain_type_def_tu = Turbulence::<_>::new(&continent_def)
            .set_seed(*CURRENT_SEED + 20)
            .set_frequency(*CONTINENT_FREQUENCY * 18.125)
            .set_power(*CONTINENT_FREQUENCY / 20.59375 * *TERRAIN_OFFSET)
            .set_roughness(3);

        // Шаг 2. Сдвиг вероятности шероховатости.
        // Использую трассировку для заострения искривленных континентов на уровне моря
        // и опускаю наклон в сторону возвышенностей, что позволяет сузить области
        // которых появляется пересеченная местность, повышая "редкость" пересеченной местности.
        let terrain_type_def_te = Terrace::new(&terrain_type_def_tu)
            .add_control_point(-1.00)
            .add_control_point(*SHELF_LEVEL + *SEA_LEVEL / 2.0)
            .add_control_point(1.00);

        // Финальный шаг подгруппы.
        // Кеширую полученный результат.
        // Это выходное значение для всей группы `ОПРЕДЕЛЕНИЕ ТИПА МЕСТНОСТИ`.
        let terrain_type_def = Cache::new(terrain_type_def_te);

        /////////////////////////////////////////////////////////////////////////////
        // Группа шагов: ГОРЫ
        /////////////////////////////////////////////////////////////////////////////

        /////////////////////////////////////////////////////////////////////////////
        // Подгруппа: Определение основания гор
        /////////////////////////////////////////////////////////////////////////////
        //
        // В результате выполнения шагов, генерирую высоты подножия горы.
        //
        // В других подгруппах добавляю горные хребты с понижением к базовым отметкам.
        //
        // -1.0 представляет самые гладкие типы местности (равнины и под водой) и
        // +1.0 представляет самые пересеченные типы местности (горы).
        /////////////////////////////////////////////////////////////////////////////

        // Шаг 1. Определение горного хребта.
        // Для генерацию использую функцию ребристого мультифрактального шума.
        let mountain_base_def_rm0 = RidgedMulti::new()
            .set_seed(*CURRENT_SEED + 30)
            .set_frequency(1723.0)
            .set_lacunarity(*MOUNTAIN_LACUNARITY)
            .set_octaves(4);

        // Шаг 2. Определение скалистых горных хребтов.
        // Использую функцию масштаба/смещения, масштабирую определенные горные хребты
        // полученные на шаге 1 так, чтобы его хребты не были слишком высоко.
        // Делаю это, чтобы позже в другой подгруппе добавить фактическую
        // гористую местность к этим хребтам.
        let mountain_base_def_sb0: ScaleBias<[f64; 3]> = ScaleBias::new(&mountain_base_def_rm0);
        let mountain_base_def_sb0 = mountain_base_def_sb0.set_scale(0.5).set_bias(0.375);

        // Шаг 3. Определение речных долин.
        // Использую функцию ребристого мультифрактального шума генерирует речные долины.
        // Применяю гораздо более низкую частоту, чем для генерации горных хребтов.
        // Это необходимо, чтобы за пределами долины появилось больше горных хребтов.
        // Важно записать, что эта шумовая функция генерирует
        // ребристо-мультифрактальные шум, использующий только одну октаву
        let mountain_base_def_rm1 = RidgedMulti::new().set_seed(*CURRENT_SEED + 31);
        let mountain_base_def_rm1 = mountain_base_def_rm1
            .set_frequency(367.0)
            .set_lacunarity(*MOUNTAIN_LACUNARITY)
            .set_octaves(1);

        // Шаг 4. Масштабирование речных долин.
        // Использую функцию масштаба/смещения применяю коэффициент масштабирования -2.0
        // для выходного значения шага 3.
        // Это растягивает возможные значения высоты, потому что ребро на одну октаву
        // мультифрактального шума имеет меньший диапазон выходных значений, чем
        // ребристо-мультифрактальный шум.
        // Отрицательный коэффициент масштабирования инвертирует диапазон выходного значения,
        // поворачивая хребты от выходного значения шага 3.
        let mountain_base_def_sb1: ScaleBias<[f64; 3]> = ScaleBias::new(&mountain_base_def_rm1);
        let mountain_base_def_sb1 = mountain_base_def_sb1.set_scale(-2.0).set_bias(-0.5);

        // Шаг 5. Создаю константу
        let mountain_base_def_co = Constant::new(-1.0);

        // Шаг 6. Горы и долины.
        // Объединяю в блендере результаты шага 3 и шага 4. Это приводит к тому, что
        // низменные участки местности становятся гладкими, а возвышенные участки
        // местности содержат гребни. Для этого используется резуьтат выполнения шага 4
        // в качестве модуля управления.
        let mountain_base_def_bl: Blend<[f64; 3]> = Blend::new(
            &mountain_base_def_co,
            &mountain_base_def_sb0,
            &mountain_base_def_sb1,
        );

        // Шаг 7. Грубая турбулентность
        // Используя турбулентность искажаю результат из шага 6, добавляя
        // случайные грубые детали нему.
        let mountain_base_def_tu0 = Turbulence::<_>::new(&mountain_base_def_bl)
            .set_seed(*CURRENT_SEED + 32)
            .set_frequency(1337.0)
            .set_power(1.0 / 6730.0 * *MOUNTAINS_TWIST)
            .set_roughness(4);

        // Шаг 8. Искревление гор и вершин.
        // Используя турбулентность  искривляю результат грубой турбулентности.
        // Данная турбулентность имеет более высокие частоты, но меньшую мощность,
        // чем в грубой турбулентности. Это добавляет случайные мелкие детали.
        let mountain_base_def_tu1: Turbulence<&Turbulence<&Blend<[f64; 3]>>> =
            Turbulence::<_>::new(&mountain_base_def_tu0)
                .set_seed(*CURRENT_SEED + 33)
                .set_frequency(21221.0)
                .set_power(1.0 / 120157.0 * *MOUNTAINS_TWIST)
                .set_roughness(6);

        // Финальный шаг подгруппы.
        // Кеширую полученный результат искривленных гор и долин.
        let mountain_base_def = Cache::new(&mountain_base_def_tu1);

        /////////////////////////////////////////////////////////////////////////////
        // Подгруппа: Высокогорная местность
        /////////////////////////////////////////////////////////////////////////////
        //
        // Эта подгруппа генерирует гористую местность, которая появляется на высоте
        // возвышенности в пределах горных хребтов.
        //
        // -1.0 представляет самые гладкие типы местности (равнины и под водой) и
        // +1.0 представляет самые пересеченные типы местности (горы).
        /////////////////////////////////////////////////////////////////////////////

        // Шаг 1. Генерация гор.
        // Использую функцию мультифрактального шума.
        let mountainous_high_rm0 = RidgedMulti::new().set_seed(*CURRENT_SEED + 40);
        let mountainous_high_rm0 = mountainous_high_rm0
            .set_frequency(2371.0)
            .set_lacunarity(*MOUNTAIN_LACUNARITY)
            .set_octaves(3);

        let mountainous_high_rm1 = RidgedMulti::new().set_seed(*CURRENT_SEED + 41);
        let mountainous_high_rm1 = mountainous_high_rm1
            .set_frequency(2341.0)
            .set_lacunarity(*MOUNTAIN_LACUNARITY)
            .set_octaves(3);

        // Шаг 2. Высокогорье
        // Попытка генерации большего кол-ва гор за счет долин. Делаю это за счет
        // обеспечения максимум выходных значений из двух ребристых функции
        // мультифрактального шума шага 1.
        let mountainous_high_ma: Max<[f64; 3]> =
            Max::new(&mountainous_high_rm0, &mountainous_high_rm1);

        // Шаг 3. Искажение высокогорья.
        // Использую турбулентность добавляю случайние детали.
        let mountainous_high_tu = Turbulence::<_>::new(&mountainous_high_ma)
            .set_seed(*CURRENT_SEED + 42)
            .set_frequency(31511.0)
            .set_power(1.0 / 180371.0 * *MOUNTAINS_TWIST)
            .set_roughness(4);

        // Финальный шаг подгруппы.
        // Кеширую результат выполнения данной подгруппы.
        let mountainous_high = Cache::new(mountainous_high_tu);

        /////////////////////////////////////////////////////////////////////////////
        // Подгруппа: Низины/Низкогорная местность
        /////////////////////////////////////////////////////////////////////////////
        //
        // Эта подгруппа генерирует гористую местность, которая появляется при низких
        // возвышенностях в долинах рек.
        //
        // -1.0 представляет самые гладкие типы местности (равнины и под водой) и
        // +1.0 представляет самые пересеченные типы местности (горы).
        /////////////////////////////////////////////////////////////////////////////

        // Шаг 1. Основание низин
        // Использую функцию ребристого мультифрактального шума, генерирую
        // низкогорную местность.
        let mountainous_low_rm0 = RidgedMulti::new()
            .set_seed(*CURRENT_SEED + 50)
            .set_frequency(1381.0)
            .set_lacunarity(*MOUNTAIN_LACUNARITY)
            .set_octaves(8);

        let mountainous_low_rm1 = RidgedMulti::new()
            .set_seed(*CURRENT_SEED + 51)
            .set_frequency(1427.0)
            .set_lacunarity(*MOUNTAIN_LACUNARITY)
            .set_octaves(8);

        // Шаг 2. Создание ландшафта низин.
        // Использую умножение для объединения двух функций гребенчатого
        // мультифрактального шума значений из шага 1.
        // Это вызывает появление следующего ландшафта:
        //
        // - Трещины — появляются при перемножении двух отрицательных выходных значений.
        //
        // - Плоские области — появляются когда положительное и
        //   отрицательное выходное значение перемножаются.
        //
        // - Ребра — появляются при перемножении двух положительных выходных значений.
        let mountainous_low_mu: Multiply<[f64; 3]> =
            Multiply::new(&mountainous_low_rm0, &mountainous_low_rm1);

        // Финальный шаг подгруппы.
        // Кеширую результат выполнения данной подгруппы.
        let mountainous_low = Cache::new(&mountainous_low_mu);

        /////////////////////////////////////////////////////////////////////////////
        // Подгруппа: Горная местность
        /////////////////////////////////////////////////////////////////////////////
        //
        // Эта подгруппа генерирует окончательный горный ландшафт, комбинируя
        // результат генерации из высокогорья и низкогорья.
        //
        // -1.0 представляет самые гладкие типы местности (равнины и под водой) и
        // +1.0 представляет самые пересеченные типы местности (горы).
        /////////////////////////////////////////////////////////////////////////////

        // Шаг 1. Масштабирование низкогорной местности.
        // Масштабирую выходное значение из подгруппы `Низины/Низкогорная местность`
        // до очень низкого значения и смещаю его в сторону -1.0. В результате
        // низкогорные местности становятся более плоскими с небольшими возвышенностями.
        // Так же. низкие горы появляются в самых низких районах данной местности.
        let mountainous_terrain_sb0 = ScaleBias::new(&mountainous_low)
            .set_scale(0.03125)
            .set_bias(-0.96875);

        // Шаг 2. Масштабирование высокогорной местности.
        // Масштабирую выходное значение из подгруппы `Высокогорье` до 1/4
        // от своего начального выходного значения и смещаю его так, чтобы его выходное
        // значение обычно положительным.
        let mountainous_terrain_sb1 = ScaleBias::new(&mountainous_high)
            .set_scale(0.25)
            .set_bias(0.25);

        // Шаг 3. Еще немного гор.
        // Вывожу дополнительное значение из шага 2, чтобы горы появлялись
        // по всей местности.
        let mountainous_terrain_ad: Add<[f64; 3]> =
            Add::new(&mountainous_terrain_sb1, &mountain_base_def);

        // Шаг 3.
        // Так как сейчас вся местность покрыта высокогорной местностью, даже на низких высотах.
        // Появление высокогорья должно ограничиваться только верхами возвышенностей.
        // Создаю отображение  гористой местности  в низкогорьях.
        // Делаю это при помощи шумовой функции, которая выбирает выходное значение из подгруппы
        // гористой местности, если выходное значение из горной базы выше установленной суммы.
        // Иначе этот шум выбирает выходное значение из масштабированного низкогорного ландшафта.
        let mountainous_terrain_se = Select::new(
            &mountainous_terrain_sb0,
            &mountainous_terrain_ad,
            &mountain_base_def,
        )
        .set_bounds(-0.5, 999.5)
        .set_falloff(0.5);

        // Шаг 4. Масштабирование горной местности.
        // Немного уменьшаю диапазон выходного значения шага 3, уменьшая высоту
        // горных вершин.
        let mountainous_terrain_sb2 = ScaleBias::new(&mountainous_terrain_se)
            .set_scale(0.8)
            .set_bias(0.0);

        // Шаг 5. Покрытие льдом.
        //
        // TODO: ЕСТЬ БАГ
        //
        // Применяю экспоненциальную кривую к выходному значению шага 4.
        //  Это приводит к тому, что склоны гор плавно увеличиваемся к более высоким отметкам,
        // как если бы ледник стачивал эти горы.
        //
        // Функция экспоненциальной кривой ожидает выходное значение в диапазоне от -1,0 до +1,0.
        let mountainous_terrain_ex =
            Exponent::new(&mountainous_terrain_sb2).set_exponent(*MOUNTAIN_GLACIATION);

        // Финальный шаг для все группы.
        // Кеширую полученный промежуточный результат.
        let mountainous_terrain = Cache::new(&mountainous_terrain_ex);

        /////////////////////////////////////////////////////////////////////////////
        // Группа шагов: ХОЛМЫ
        /////////////////////////////////////////////////////////////////////////////

        /////////////////////////////////////////////////////////////////////////////
        // Подгруппа: Холмистая местность
        /////////////////////////////////////////////////////////////////////////////
        //
        // Эта подгруппа генерирует холмистую местность.
        //
        // -1.0 представляет самые гладкие типы местности (равнины и под водой) и
        // +1.0 представляет самые пересеченные типы местности (горы).
        /////////////////////////////////////////////////////////////////////////////

        // Шаг 1. Генерация холмов с применением волновой функции
        let hilly_terrain_bi = Billow::new()
            .set_seed(*CURRENT_SEED + 60)
            .set_frequency(1663.0)
            .set_persistence(0.5)
            .set_lacunarity(*HILLS_LACUNARITY)
            .set_octaves(6);

        // Шаг 2. Применяю  масштабирования/смещения для результата из шага 1.
        // Это убирает слишком высокие вершины.
        let hilly_terrain_sb0: ScaleBias<[f64; 3]> = ScaleBias::new(&hilly_terrain_bi);
        let hilly_terrain_sb0 = hilly_terrain_sb0.set_scale(0.5).set_bias(0.5);

        // Шаг 3. Создание речных долин.
        // Использую функцию ребристого мультифрактального шума для генерации речных долин.
        // Задаю гораздо более низкую частоту, чтобы появлялось больше холмов между долинами.
        let hilly_terrain_rm = RidgedMulti::new()
            .set_seed(*CURRENT_SEED + 61)
            .set_frequency(367.5)
            .set_lacunarity(*HILLS_LACUNARITY)
            .set_octaves(1);

        // Шаг 4. Применяю коэффициент масштабирования -2.0 для выходного значния шага 3.
        // Это растягивает возможные значения высоты, поскольку однооктавный
        // ребристо-мультифрактальный шум имеет меньший диапазон выходных значений,
        // чем многооктавный ребристо-мультифрактальный шум. Отрицательный коэффициент
        // масштабирования инвертирует диапазон выходного значения, поворачивая хребты
        // от долин рек в долины.
        let hilly_terrain_sb1: ScaleBias<[f64; 3]> = ScaleBias::new(&hilly_terrain_rm);
        let hilly_terrain_sb1 = hilly_terrain_sb1.set_scale(-2.0).set_bias(-1.0);

        let hilly_terrain_co = Constant::new(-1.0);

        // Шаг 5. Объединяю результат генерации холмов и речнх долин.
        // Это приводит к тому, что низменные участки местности становятся гладкими,
        // а возвышенные участки местности содержат гребни.
        let hilly_terrain_bl: Blend<[f64; 3]> =
            Blend::new(&hilly_terrain_co, &hilly_terrain_sb1, &hilly_terrain_sb0);

        // Шаг 6. Использую функцию масштаба/смещения немного уменьшаю диапазон
        // выходного значения из шага 5, что позволяет уменьшить высоту вершин холмов.
        let hilly_terrain_sb2: ScaleBias<[f64; 3]> = ScaleBias::new(&hilly_terrain_bl)
            .set_scale(0.75)
            .set_bias(-0.25);

        // Шаг 7. Увеличение уклона холмов.
        // На больших высотах эта функция экспоненциальной кривой применяется
        // к выходному значению из шага 6. Эта функция экспоненциальной кривой ожидает,
        // что входное значение будет находиться в диапазоне от -1,0 до 1,0.
        let hilly_terrain_ex = Exponent::new(&hilly_terrain_sb2).set_exponent(1.375);

        // Шаг 8. Применяю турбулентность для добавления грубых деталей
        // для выходного значения из шага 7.
        let hilly_terrain_tu0: Turbulence<&Exponent<[f64; 3]>> = Turbulence::new(&hilly_terrain_ex)
            .set_seed(*CURRENT_SEED + 62)
            .set_frequency(1531.0)
            .set_power(1.0 / 16921.0 * *HILLS_TWIST)
            .set_roughness(4);

        // Шаг 8. Применяю турбулентность для добавления мелких деталей.
        // Задаю более высокую частоту, но меньшую мощность, относительно шага 8.
        let hilly_terrain_tu1 = Turbulence::<_>::new(&hilly_terrain_tu0)
            .set_seed(*CURRENT_SEED + 63)
            .set_frequency(21617.0)
            .set_power(1.0 / 117529.0 * *HILLS_TWIST)
            .set_roughness(6);

        // Финальный шаг для всей группы
        // Кеширование текущего промежуточного результата.
        let hilly_terrain = Cache::new(hilly_terrain_tu1);

        /////////////////////////////////////////////////////////////////////////////
        // Группа шагов: РАВНИНЫ
        /////////////////////////////////////////////////////////////////////////////

        /////////////////////////////////////////////////////////////////////////////
        // Подгруппа: Равнинная местность
        /////////////////////////////////////////////////////////////////////////////
        //
        // Эта подгруппа генерирует равнинный ландшафт.
        // Поскольку эта подгруппа в конечном итоге будет значительно сплющена,
        // типы и комбинации шумовых функций, которые генерируют равнины,
        // не имеют значительного эффекта на конечный результат.
        //
        // -1.0 представляет самые гладкие типы местности (равнины и под водой) и
        // +1.0 представляет самые пересеченные типы местности (горы).
        /////////////////////////////////////////////////////////////////////////////

        // Шаг 1. Создание равнин через функцию шумоподавления.
        let plains_terrain_bi0 = Billow::new()
            .set_seed(*CURRENT_SEED + 70)
            .set_frequency(1097.5)
            .set_persistence(0.5)
            .set_lacunarity(*PLAINS_LACUNARITY)
            .set_octaves(8);

        // Шаг 2. Применяю функцию масштаба/смещения, чтобы выходное значение
        // шага 1 было положительным.
        let plains_terrain_sb0: ScaleBias<[f64; 3]> = ScaleBias::new(&plains_terrain_bi0);
        let plains_terrain_sb0 = plains_terrain_sb0.set_scale(0.5).set_bias(0.5);

        // Шаг 3. Еще раз шумоподавление.
        let plains_terrain_bi1 = Billow::new()
            .set_seed(*CURRENT_SEED + 71)
            .set_frequency(1097.5)
            .set_persistence(0.5)
            .set_lacunarity(*PLAINS_LACUNARITY)
            .set_octaves(8);

        // Шаг 4. Применяю функцию масштаба/смещения, чобы получить положительный результат.
        let plains_terrain_sb1: ScaleBias<[f64; 3]> = ScaleBias::new(&plains_terrain_bi1);
        let plains_terrain_sb1 = plains_terrain_sb1.set_scale(0.5).set_bias(0.5);

        // Шаг 5. Объединение базового реультата и равнин.
        let plains_terrain_mu: Multiply<[f64; 3]> =
            Multiply::new(&plains_terrain_sb0, &plains_terrain_sb1);

        // Шаг 6.
        // Применяю функцию масштаба/смещения, которая преобразует выходное значение
        // в диапазоне от 0,0 до 1,0 обратно в значение в диапазоне от -1,0 до +1,0.
        let plains_terrain_sb2: ScaleBias<[f64; 3]> = ScaleBias::new(&plains_terrain_mu)
            .set_scale(2.0)
            .set_bias(-1.0);

        // Финальный шаг для всей группы
        // Кеширование промежуточного результата
        let plains_terrain: Cache<ScaleBias<[f64; 3]>> = Cache::new(plains_terrain_sb2);

        /////////////////////////////////////////////////////////////////////////////
        // Группа шагов: БЕСПЛОДНЫЕ ЗЕМЛИ
        /////////////////////////////////////////////////////////////////////////////

        /////////////////////////////////////////////////////////////////////////////
        // Подгруппа: Песок бесплодных земель
        /////////////////////////////////////////////////////////////////////////////
        //
        // Эта подгруппа генерирует песчаный ландшафт для бесплодных земель.
        //
        // -1.0 представляет самые гладкие типы местности (равнины и под водой) и
        // +1.0 представляет самые пересеченные типы местности (горы).
        /////////////////////////////////////////////////////////////////////////////

        // Шаг 1. Применяю функцию ребристого мультифрактального шума для генерации
        // песчаных дюн. Использую однооктавный шум для создания гладких дюн.
        let badlands_sand_rm = RidgedMulti::new()
            .set_seed(*CURRENT_SEED + 80)
            .set_frequency(6163.5)
            .set_lacunarity(*BADLANDS_LACUNARITY)
            .set_octaves(1);

        // Шаг 2. Создание чешуйчатых дюн.
        // Уменьшаю высоту дюн на небольшую величину. Это необходимо, чтобы потом можно
        // было добавить случайнве детали к дюнам.
        let badlands_sand_sb0: ScaleBias<[f64; 3]> = ScaleBias::new(&badlands_sand_rm);
        let badlands_sand_sb0 = badlands_sand_sb0.set_scale(0.875).set_bias(0.0);

        // Шаг 3. Применяю полигоны Вороного для генерации деталей в дюнах.
        // Создаются небольшие полигональные ямы, их края сиеденяются с краями ближайших ям.
        let badlands_sand_wo = Worley::new()
            .set_seed(*CURRENT_SEED + 81)
            .set_frequency(16183.25);

        // Шаг 4. Через функцию масштабирования/смещения значительно уменьшаю детали дюн.
        let badlands_sand_sb1: ScaleBias<[f64; 3]> = ScaleBias::new(&badlands_sand_wo);
        let badlands_sand_sb1 = badlands_sand_sb1.set_scale(0.25).set_bias(0.25);

        // Шаг 5. Объединяю дюны с деталями с обычными дюнами.
        let badlands_sand_ad = Add::new(&badlands_sand_sb0, &badlands_sand_sb1);

        // Финальный шаг подгруппы
        // Кеширование промежуточного результата
        let badlands_sand: Cache<&Add<[f64; 3]>> = Cache::new(&badlands_sand_ad);

        /////////////////////////////////////////////////////////////////////////////
        // Подгруппа: Скалы бесплодных земель
        /////////////////////////////////////////////////////////////////////////////
        //
        // Эта подгруппа генерирует скалы для бесплодных земель.
        //
        // -1.0 представляет самые гладкие типы местности (равнины и под водой) и
        // +1.0 представляет самые пересеченные типы местности (горы).
        /////////////////////////////////////////////////////////////////////////////

        // Шаг 1. Генерирую когерентный шум, чтобы потом с помощью него создавать обрывы.
        let badlands_cliffs_fb = Fbm::new()
            .set_seed(*CURRENT_SEED + 90)
            .set_frequency(*CONTINENT_FREQUENCY * 839.0)
            .set_persistence(0.5)
            .set_lacunarity(*BADLANDS_LACUNARITY)
            .set_octaves(6);

        // Шаг 2. Применяю функцию кривой к результату шага 1.
        // Кривая изначально пологая, но затем ее наклон резко возрастает.
        // На самом высоком высоты кривая снова становится очень плоской.
        // Это создает обвесные пустынные скалы.
        let badlands_cliffs_cu: Curve<[f64; 3]> = Curve::new(&badlands_cliffs_fb);
        let badlands_cliffs_cu = badlands_cliffs_cu
            .add_control_point(-2.000, -2.000)
            .add_control_point(-1.000, -1.000)
            .add_control_point(-0.000, -0.750)
            .add_control_point(0.500, -0.250)
            .add_control_point(0.625, 0.875)
            .add_control_point(0.750, 1.000)
            .add_control_point(2.000, 1.250);

        // Шаг 3. Делаю плоскими обрывы полученные на шаге 2.
        let badlands_cliffs_cl = Clamp::new(&badlands_cliffs_cu).set_bounds(-999.125, 0.875);

        // Шаг 4. Создание терассных скал, на основе шага 3.
        // Скалы в нижних отметках будут иметь резкий обрыв.
        let badlands_cliffs_te: Terrace<[f64; 3]> = Terrace::new(&badlands_cliffs_cl)
            .add_control_point(-1.000)
            .add_control_point(-0.875)
            .add_control_point(-0.750)
            .add_control_point(-0.500)
            .add_control_point(0.000)
            .add_control_point(1.000);

        // Шаг 5. Турбулентностью искажаю результат шага 4,
        // Добавляю к нему случайные грубые детали.
        let badlands_cliffs_tu0: Turbulence<&Terrace<[f64; 3]>> =
            Turbulence::new(&badlands_cliffs_te)
                .set_seed(*CURRENT_SEED + 91)
                .set_frequency(16111.0)
                .set_power(1.0 / 141539.0 * *BADLANDS_TWIST)
                .set_roughness(3);

        // Шаг 6. Искривление скал
        //  Искажаю резултьтат грубой турбулентности, добавляя мелкие детали.
        let badlands_cliffs_tu1: Turbulence<&Turbulence<&Terrace<[f64; 3]>>> =
            Turbulence::new(&badlands_cliffs_tu0)
                .set_seed(*CURRENT_SEED + 92)
                .set_frequency(36107.0)
                .set_power(1.0 / 211543.0 * *BADLANDS_TWIST)
                .set_roughness(3);

        // Финальный шаг подгруппы
        // Кеширование промежуточного результата
        let badlands_cliffs = Cache::new(&badlands_cliffs_tu1);

        /////////////////////////////////////////////////////////////////////////////
        // Подгруппа: Ландшафт бесплодных земель
        /////////////////////////////////////////////////////////////////////////////
        //
        // Генерирует окончательный ландшафт бесплодных земель.
        // Выравниваю песок бесплодных земель, затем снижаю высоту песка до -1.0.
        // Делаю появление песка тольклько на низких высотах.
        //
        // -1.0 представляет самые гладкие типы местности (равнины и под водой) и
        // +1.0 представляет самые пересеченные типы местности (горы).
        /////////////////////////////////////////////////////////////////////////////

        // Шаг 1. Ровняю результат подгруппы бесплодных земель.
        // Понижаю значение близко к -1.0.
        let badlands_terrain_sb = ScaleBias::new(&badlands_sand)
            .set_scale(0.25)
            .set_bias(-0.75);

        // Шаг 2. Создаю условия, чтобы дюны появлялись только в низких облостях,
        // а скалы только в высоких.
        let badlands_terrain_ma: Max<[f64; 3]> = Max::new(&badlands_cliffs, &badlands_terrain_sb);

        // Финальный шаг группы
        // Кеширование промежуточного результата
        let badlands_terrain: Cache<&Max<[f64; 3]>> = Cache::new(&badlands_terrain_ma);

        /////////////////////////////////////////////////////////////////////////////
        // Группа шагов: РЕКИ
        /////////////////////////////////////////////////////////////////////////////

        /////////////////////////////////////////////////////////////////////////////
        // Подгруппа: Позиция рек
        /////////////////////////////////////////////////////////////////////////////
        //
        // Эта подгруппа генерирует положение рек на текущей местности.
        //
        // -1.0 представляет самые гладкие типы местности (равнины и под водой) и
        // +1.0 представляет самые пересеченные типы местности (горы).
        /////////////////////////////////////////////////////////////////////////////

        // Шаг 1. Создание широких и глубоких рек через применение
        // ребристого мультифрактального шума.
        let river_positions_rm0 = RidgedMulti::new()
            .set_seed(*CURRENT_SEED + 100)
            .set_frequency(18.75)
            .set_lacunarity(*CONTINENT_LACUNARITY)
            .set_octaves(1);

        // Шаг 2. Инвертирую горные хребты и снижаю край рек, создавая
        // резкий переход от суши к реке.
        let river_positions_cu0: Curve<[f64; 3]> = Curve::new(&river_positions_rm0);
        let river_positions_cu0 = river_positions_cu0
            .add_control_point(-2.000, 2.000)
            .add_control_point(-1.000, 1.000)
            .add_control_point(-0.125, 0.875)
            .add_control_point(0.000, -1.000)
            .add_control_point(1.000, -1.500)
            .add_control_point(2.000, -2.000);

        // Шаг 3. Создание неглубоких рек через использование
        // ребристого мультифрактального шума.
        let river_positions_rm1 = RidgedMulti::new()
            .set_seed(*CURRENT_SEED + 101)
            .set_frequency(43.25)
            .set_lacunarity(*CONTINENT_LACUNARITY)
            .set_octaves(1);

        // Шаг 4. Повторяю операции из шага 2 для шага 3.
        let river_positions_cu1: Curve<[f64; 3]> = Curve::new(&river_positions_rm1);
        let river_positions_cu1 = river_positions_cu1
            .add_control_point(-2.000, 2.0000)
            .add_control_point(-1.000, 1.5000)
            .add_control_point(-0.125, 1.4375)
            .add_control_point(0.000, 0.5000)
            .add_control_point(1.000, 0.2500)
            .add_control_point(2.000, 0.0000);

        // Шаг 5. Объединение больших рек с маленькими.
        let river_positions_mi: Min<[f64; 3]> =
            Min::new(&river_positions_cu0, &river_positions_cu1);

        // Шаг 6. Искажаю выходное значение полученное в результате комбинирования типов рек.
        // Это немного скручивает реки и добовляет шероховатости в шум.
        let river_positions_tu: Turbulence<&Min<[f64; 3]>> =
            Turbulence::<_>::new(&river_positions_mi)
                .set_seed(*CURRENT_SEED + 102)
                .set_frequency(9.25)
                .set_power(1.0 / 57.75)
                .set_roughness(6);

        // Финальный шаг подгруппы
        // Кеширование промежуточного результата
        let river_positions: Cache<&Turbulence<&Min<[f64; 3]>>> = Cache::new(&river_positions_tu);

        /////////////////////////////////////////////////////////////////////////////
        // Группа шагов: ГОРНЫЙ РЕЛЬЕФ
        /////////////////////////////////////////////////////////////////////////////

        /////////////////////////////////////////////////////////////////////////////
        // Подгруппа: Масштабированный горный рельеф
        /////////////////////////////////////////////////////////////////////////////
        //
        // Эта подгруппа масштабирует выходное значение из группы горной местности
        // чтобы его можно было добавить к высоте, определяемой континентом.
        // Подгруппа масштабирует выходное значение таким образом, чтобы оно почти всегда
        // было положительным. Делаю это для того, чтобы не применялась отрицательная отметка
        // к группе определяющей континенты.
        //
        // Выходное значение этой подгруппы модулей измеряется в планетарных где:
        // -1.0 представляет самые гладкие типы местности (равнины и под водой) и
        // +1.0 представляет самые пересеченные типы местности (горы).
        /////////////////////////////////////////////////////////////////////////////

        // Шаг 1. Функцией масштаба/смещения масштабирую выходное значение полученное
        // в греппе генерации гор так, чтобы выходное значение измеряется в п
        // ланетарных единицах высоты.
        let scaled_mountainous_terrain_sb0 = ScaleBias::new(&mountainous_terrain)
            .set_scale(0.125)
            .set_bias(0.125);

        // Шаг 2. На данном этапе высота гор везде линейно равна. Поэтому создаю шум
        // который в дальнейшем использую в шумовых функциях для рандомизации горных высот.
        let scaled_mountainous_terrain_fb = Fbm::new()
            .set_seed(*CURRENT_SEED + 110)
            .set_frequency(14.5)
            .set_persistence(0.5)
            .set_lacunarity(*MOUNTAIN_LACUNARITY)
            .set_octaves(6);

        // Шаг 3. Создаю экспоненциальную кривую которую применяю к шагу 2. Это дает
        // небольшое количество высоких значений и гораздо большее количество низких значений.
        // Это гарантирует, что в мире будет существовать несколько высоких горных пиков,
        // чем большинство остальных горных массивов. Это дает более разнообразный ландшафт.
        let scaled_mountainous_terrain_ex: Exponent<[f64; 3]> =
            Exponent::new(&scaled_mountainous_terrain_fb);
        let scaled_mountainous_terrain_ex = scaled_mountainous_terrain_ex.set_exponent(1.25);

        // Шаг 4. Применяю функцию масштабирования/смещения для шага 3. Это необходимо
        // чтобы это выходное значение было не намного меньше 1,0.
        let scaled_mountainous_terrain_sb1 = ScaleBias::new(&scaled_mountainous_terrain_ex)
            .set_scale(0.25)
            .set_bias(1.0);

        // Шаг 5. Моделирую высоту горных вершин на основе генерации горных пиков
        let scaled_mountainous_terrain_mu = Multiply::new(
            &scaled_mountainous_terrain_sb0,
            &scaled_mountainous_terrain_sb1,
        );

        // Финальный шаг подгруппы
        // Кеширование промежуточного результата. Это выходное значение для всей горной местности.
        let scaled_mountainous_terrain = Cache::new(&scaled_mountainous_terrain_mu);

        /////////////////////////////////////////////////////////////////////////////
        // Группа шагов: МАСШТАБИРУЕМАЯ ХОЛМИСТАЯ МЕСТНОСТЬ
        /////////////////////////////////////////////////////////////////////////////

        /////////////////////////////////////////////////////////////////////////////
        // Подгруппа: Масштабируемая холмистая местность
        /////////////////////////////////////////////////////////////////////////////
        //
        // Эта подгруппа масштабирует выходное значение из группы холмистой местност.
        // Величина масштабирования, применяемая к холмам, составляет половину величины
        // масштабирования от примененной к к группе масштабируемой горной местности.
        //
        // Подгруппа масштабирует выходное значение таким образом, чтобы оно почти всегда
        // было положительным. Это сделано для того, чтобы отрицательные отметки не применялись
        // к группе определенных континентов.
        //
        // Выходное значение этой подгруппы модулей измеряется в планетарных где:
        // -1.0 представляет самые гладкие типы местности (равнины и под водой) и
        // +1.0 представляет самые пересеченные типы местности (горы).
        /////////////////////////////////////////////////////////////////////////////

        // Шаг 1. Через функицю масштаба/смещения масштабирую выходное значение из группы
        // холмистой местности, чтобы это выходное значение было измеряется в
        // планетарных единицах высоты.
        let scaled_hilly_terrain_sb0 = ScaleBias::new(&hilly_terrain)
            .set_scale(0.0625)
            .set_bias(0.0625);

        // Шаг 2. Высотах всех холмов примерна одинакома, посему применяю шумовую функцию
        // для создания разной высоты у холмов.
        let scaled_hilly_terrain_fb = Fbm::new()
            .set_seed(*CURRENT_SEED + 120)
            .set_frequency(13.5)
            .set_persistence(0.5)
            .set_lacunarity(*HILLS_LACUNARITY)
            .set_octaves(6);

        // Шаг 3. Добавляю больше разнообразия. В мире должно появиться немного высоких холмов
        // и много разных, но с более низким показателем по высоте.
        let scaled_hilly_terrain_ex: Exponent<[f64; 3]> = Exponent::new(&scaled_hilly_terrain_fb);
        let scaled_hilly_terrain_ex = scaled_hilly_terrain_ex.set_exponent(1.25);

        // Шаг 4. Применяю функцию масштаба/смещения для выходного значения из шага 3.
        let scaled_hilly_terrain_sb1 = ScaleBias::new(&scaled_hilly_terrain_ex)
            .set_scale(0.5)
            .set_bias(1.5);

        // Шаг 5. Еще немного преобразований для значений из шага 4.
        let scaled_hilly_terrain_mu =
            Multiply::new(&scaled_hilly_terrain_sb0, &scaled_hilly_terrain_sb1);

        // Финальный шаг группы
        // Кеширование промежуточного результата. Это выходное значение для всей холмистой местности.
        let scaled_hilly_terrain = Cache::new(&scaled_hilly_terrain_mu);
    }
}
